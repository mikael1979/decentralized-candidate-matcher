🐍 PYTHON-KOODIKOKOELMA
======================
Luotu: ti 28.10.2025 10.33.44 +0200
Hakemisto: /home/toni/Ohjelmointi/HajautettuVaalikone/decentralized-candidate-matcher

┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./test_installation.py                               │
│ Koko: 34     riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./admin_based/mock_ipfs.py                           │
│ Koko: 178    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./admin_based/admin_api.py                           │
│ Koko: 233    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./admin_based/superadmin_setting_tool.py             │
│ Koko: 585    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./admin_based/test_api_sanitization.py               │
│ Koko: 48     riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./admin_based/security_test.py                       │
│ Koko: 789    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./admin_based/real_ipfs.py                           │
│ Koko: 123    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./admin_based/admin_settings_api.py                  │
│ Koko: 118    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./admin_based/json_editor.py                         │
│ Koko: 286    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./admin_based/json_editor_with_ipfs.py               │
│ Koko: 532    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./admin_based/web_app.py                             │
│ Koko: 308    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./admin_based/data_schemas.py                        │
│ Koko: 196    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./admin_based/candidate_management_api.py            │
│ Koko: 138    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./admin_based/data_manager.py                        │
│ Koko: 144    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./admin_based/quick_fix.py                           │
│ Koko: 46     riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./admin_based/utils.py                               │
│ Koko: 515    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./admin_based/route_handlers.py                      │
│ Koko: 415    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./admin_based/services/console_ui.py                 │
│ Koko: 94     riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./admin_based/services/election_policy.py            │
│ Koko: 54     riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./admin_based/services/security.py                   │
│ Koko: 161    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./admin_based/services/installation_verifier.py      │
│ Koko: 81     riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./admin_based/services/key_manager.py                │
│ Koko: 58     riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./admin_based/services/__init__.py                   │
│ Koko: 0      riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./admin_based/services/election_collector.py         │
│ Koko: 39     riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./admin_based/services/election_locker.py            │
│ Koko: 83     riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./admin_based/services/time_lock_collector.py        │
│ Koko: 22     riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./admin_based/services/install_data_loader.py        │
│ Koko: 87     riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./admin_based/services/system_chain_creator.py       │
│ Koko: 62     riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./admin_based/services/ipfs_sync.py                  │
│ Koko: 145    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./admin_based/services/meta_service.py               │
│ Koko: 159    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./admin_based/services/config_generator.py           │
│ Koko: 45     riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./admin_based/services/content_service.py            │
│ Koko: 233    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./admin_based/party_management_api.py                │
│ Koko: 178    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./admin_based/install.py                             │
│ Koko: 16     riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./admin_based/installation_manager.py                │
│ Koko: 214    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./community_based/ipfs_sync_manager.py               │
│ Koko: 126    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./community_based/candidate_pipeline.py              │
│ Koko: 105    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./community_based/mock_ipfs.py                       │
│ Koko: 124    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./community_based/complete_bidirectional_sync.py     │
│ Koko: 77     riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./community_based/mock_ipfs_sync_ready.py            │
│ Koko: 124    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./community_based/installation_engine_sync.py        │
│ Koko: 53     riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./community_based/demo_cid_sync.py                   │
│ Koko: 73     riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./community_based/initialization.py                  │
│ Koko: 59     riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./community_based/example_usage.py                   │
│ Koko: 61     riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./community_based/cid_sync_manager.py                │
│ Koko: 150    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./community_based/metadata_manager.py                │
│ Koko: 208    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./community_based/test_modular_installation.py       │
│ Koko: 117    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./community_based/candidate_ipfs_sync.py             │
│ Koko: 76     riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./community_based/ipfs_sync_engine.py                │
│ Koko: 368    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./community_based/create_install_config.py           │
│ Koko: 378    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./community_based/question_pipeline.py               │
│ Koko: 55     riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./community_based/test_mock_ipfs.py                  │
│ Koko: 71     riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./community_based/unified_sync_manager.py            │
│ Koko: 73     riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./community_based/ipfs_sync.py                       │
│ Koko: 71     riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./community_based/mock_sync_manager.py               │
│ Koko: 214    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./community_based/installation_engine.py             │
│ Koko: 362    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./community_based/install.py                         │
│ Koko: 239    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./test/IPFS/vanha_testi/question_submission.py       │
│ Koko: 236    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./test/IPFS/vanha_testi/test_candidate_profile.py    │
│ Koko: 118    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./test/IPFS/vanha_testi/test_full_system.py          │
│ Koko: 208    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./test/IPFS/vanha_testi/cli_question_interface.py    │
│ Koko: 225    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./test/IPFS/vanha_testi/party_profile.py             │
│ Koko: 438    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./test/IPFS/vanha_testi/app.py                       │
│ Koko: 147    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./test/IPFS/vanha_testi/candidate_registration.py    │
│ Koko: 119    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./test/IPFS/vanha_testi/test_enhanced_question_system.py │
│ Koko: 110    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./test/IPFS/vanha_testi/ipfs.py                      │
│ Koko: 420    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./test/IPFS/vanha_testi/test_candidate_registration.py │
│ Koko: 103    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./test/IPFS/vanha_testi/search_engine.py             │
│ Koko: 176    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./test/IPFS/vanha_testi/candidate_answers.py         │
│ Koko: 69     riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./test/IPFS/vanha_testi/test_new_manager.py          │
│ Koko: 113    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./test/IPFS/vanha_testi/test_complete_pipeline.py    │
│ Koko: 43     riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./test/IPFS/vanha_testi/test_party_profiles.py       │
│ Koko: 126    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./test/IPFS/vanha_testi/election_data_manager.py     │
│ Koko: 335    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./test/IPFS/vanha_testi/test_search_engine.py        │
│ Koko: 195    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./test/IPFS/vanha_testi/cli_interface.py             │
│ Koko: 142    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./test/IPFS/vanha_testi/candidate_profile.py         │
│ Koko: 174    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./test/IPFS/web_app.py                               │
│ Koko: 35     riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./test/admin_tool.py                                 │
│ Koko: 717    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./test/test_security.py                              │
│ Koko: 563    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./test/json_editor.py                                │
│ Koko: 476    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./test/key_manager.py                                │
│ Koko: 165    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./test/models.py                                     │
│ Koko: 140    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./test/demo.py                                       │
│ Koko: 842    riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│ Tiedosto: ./test/config.py                                     │
│ Koko: 72     riviä                                        │
└──────────────────────────────────────────────────────────────┘




┌──────────────────────────────────────────────────────────────┐
│                          YHTEENVETO                          │
├──────────────────────────────────────────────────────────────┤
│ Tiedostoja: 84                                          │
│ Rivejä yhteensä: 16110                                   │
│ Keskimäärin: 191,0  riviä/tiedosto                          │
│ Luotu: 2025-10-28 10:33:45                                      │
└──────────────────────────────────────────────────────────────┘
# candidate_ipfs_sync.py
class CandidateIPFSSync:
    def __init__(self, runtime_dir="runtime"):
        self.runtime_dir = runtime_dir
        
    def sync_candidates_to_ipfs(self):
        """Synkronoi candidate_profiles.json → ipfs_candidate_profiles.json → IPFS"""
        # 1. Lataa candidate_profiles.json
        profiles = self._load_json('candidate_profiles.json')
        
        # 2. Päivitä ipfs_candidate_profiles.json
        ipfs_profiles = {
            "metadata": {
                "synced_at": datetime.now().isoformat(),
                "source_hash": self._calculate_hash(profiles),
                "total_candidates": len(profiles['candidates']),
                "total_answers": self._count_total_answers(profiles),
                "ipfs_cid": None
            },
            "candidates": profiles['candidates']
        }
        
        # 3. Tallenna ipfs_candidate_profiles.json
        self._save_json('ipfs_candidate_profiles.json', ipfs_profiles)
        
        # 4. Lähetä IPFS:ään
        ipfs_cid = self._upload_to_ipfs(ipfs_profiles)
        ipfs_profiles['metadata']['ipfs_cid'] = ipfs_cid
        
        # 5. Päivitä ipfs_candidate_profiles.json CID:llä
        self._save_json('ipfs_candidate_profiles.json', ipfs_profiles)
        
        # 6. Päivitä meta.json
        meta = self._load_json('meta.json')
        if 'ipfs_candidates_cid' not in meta:
            meta['ipfs_candidates_cid'] = {}
        meta['ipfs_candidates_cid'] = ipfs_cid
        meta['last_candidate_sync'] = datetime.now().isoformat()
        self._save_json('meta.json', meta)
        
        print(f"Ehdokkaat synkronoitu IPFS:ään CID: {ipfs_cid}")
        return ipfs_cid
        
    def sync_ipfs_to_candidates(self):
        """Synkronoi IPFS → ipfs_candidate_profiles.json → candidate_profiles.json"""
        # 1. Hae viimeisin CID meta.json:sta
        meta = self._load_json('meta.json')
        cid = meta.get('ipfs_candidates_cid')
        
        if not cid:
            print("Ei CID:ä saatavilla ehdokkaille")
            return None
            
        # 2. Hae data IPFS:stä
        ipfs_data = self._download_from_ipfs(cid)
        
        # 3. Tallenna väliaikaisesti
        self._save_json('tmp_ipfs_candidate_profiles.json', ipfs_data)
        
        # 4. Merge candidate_profiles.json:iin
        local_profiles = self._load_json('candidate_profiles.json')
        
        # Yksinkertainen merge: korvaa koko sisältö
        # Tässä voisi olla älykkäämpi konfliktien hallinta
        local_profiles['candidates'] = ipfs_data['candidates']
        local_profiles['metadata']['last_ipfs_sync'] = datetime.now().isoformat()
        local_profiles['metadata']['total_candidates'] = len(ipfs_data['candidates'])
        
        # 5. Tallenna candidate_profiles.json
        self._save_json('candidate_profiles.json', local_profiles)
        
        # 6. Vahvista synkronointi
        self._save_json('ipfs_candidate_profiles.json', ipfs_data)
        
        print(f"Ehdokkaat synkronoitu IPFS:stä CID: {cid}")
        return cid
# candidate_pipeline.py
class CandidatePipeline:
    def __init__(self, runtime_dir="runtime"):
        self.runtime_dir = runtime_dir
        
    def add_new_candidate_profile(self, candidate_data):
        """Lisää uusi ehdokasprofiili putkeen"""
        # 1. Lataa new_candidate_profiles.json
        new_profiles = self._load_json('new_candidate_profiles.json')
        
        # 2. Luo tmp_new_candidate_profiles.json
        tmp_profiles = new_profiles.copy()
        
        # 3. Lisää uusi ehdokas väliaikaiseen tiedostoon
        candidate_id = self._generate_candidate_id()
        candidate_data['candidate_id'] = candidate_id
        candidate_data['profile_metadata'] = {
            'status': 'new',
            'created_at': datetime.now().isoformat(),
            'last_modified': datetime.now().isoformat(),
            'version': '1.0.0',
            'completeness_score': self._calculate_completeness(candidate_data)
        }
        
        tmp_profiles['candidates'].append(candidate_data)
        
        # 4. Tallenna tmp tiedosto
        self._save_json('tmp_new_candidate_profiles.json', tmp_profiles)
        
        return candidate_id
        
    def add_candidate_answer(self, candidate_id, question_id, answer_data):
        """Lisää vastaus ehdokkaan profiiliin"""
        # 1. Lataa candidate_profiles.json
        profiles = self._load_json('candidate_profiles.json')
        
        # 2. Etsi ehdokas
        candidate = self._find_candidate(profiles, candidate_id)
        if not candidate:
            raise ValueError(f"Ehdokasta ei löydy: {candidate_id}")
            
        # 3. Päivitä tai lisää vastaus
        existing_answer = None
        for answer in candidate['answers']:
            if answer['question_id'] == question_id:
                existing_answer = answer
                break
                
        if existing_answer:
            # Päivitä olemassa oleva vastaus
            existing_answer.update({
                'answer_value': answer_data['answer_value'],
                'explanation': answer_data['explanation'],
                'confidence': answer_data.get('confidence', 3),
                'last_updated': datetime.now().isoformat()
            })
        else:
            # Lisää uusi vastaus
            candidate['answers'].append({
                'question_id': question_id,
                'answer_value': answer_data['answer_value'],
                'explanation': answer_data['explanation'],
                'confidence': answer_data.get('confidence', 3),
                'last_updated': datetime.now().isoformat()
            })
        
        # 4. Päivitä profiilin metadata
        candidate['profile_metadata']['last_modified'] = datetime.now().isoformat()
        candidate['profile_metadata']['completeness_score'] = self._calculate_completeness(candidate)
        
        # 5. Tallenna
        self._save_json('candidate_profiles.json', profiles)
        
        print(f"Vastaus lisätty ehdokkaalle {candidate_id}, kysymys {question_id}")
        
    def sync_new_candidates_to_main(self):
        """Synkronoi new_candidate_profiles.json → candidate_profiles.json"""
        # 1. Lataa tmp_new_candidate_profiles.json
        tmp_profiles = self._load_json('tmp_new_candidate_profiles.json')
        
        # 2. Lataa candidate_profiles.json
        main_profiles = self._load_json('candidate_profiles.json')
        
        # 3. Siirrä uudet ehdokkaat
        new_count = 0
        for candidate in tmp_profiles['candidates']:
            if candidate['profile_metadata']['status'] == 'new':
                candidate['profile_metadata']['status'] = 'active'
                main_profiles['candidates'].append(candidate)
                new_count += 1
        
        # 4. Päivitä metadata
        main_profiles['metadata']['total_candidates'] = len(main_profiles['candidates'])
        main_profiles['metadata']['last_updated'] = datetime.now().isoformat()
        
        # 5. Päivitä tiedostot
        self._save_json('candidate_profiles.json', main_profiles)
        
        # 6. Tyhjennä tmp ja päivitä new_candidate_profiles
        tmp_profiles['candidates'] = [c for c in tmp_profiles['candidates'] if c['profile_metadata']['status'] != 'new']
        self._save_json('new_candidate_profiles.json', tmp_profiles)
        self._save_json('tmp_new_candidate_profiles.json', {'candidates': []})
        
        print(f"Synkronoitu {new_count} uutta ehdokasta")
        return new_count
# cid_sync_manager.py
class CIDSyncManager:
    def __init__(self, runtime_dir="runtime", local_system_id=None):
        self.runtime_dir = runtime_dir
        self.local_system_id = local_system_id or self._generate_system_id()
    
    def sync_questions_to_ipfs(self):
        """Synkronoi vain paikallisesti lisätyt kysymykset IPFS:ään"""
        print("=== QUESTIONS.JSON → IPFS_QUESTIONS.JSON SYNKRONOINTI ===")
        
        # 1. Lataa questions.json
        questions_data = self._load_json('questions.json')
        
        # 2. Erota paikallisesti lisätyt kysymykset (joilla ei ole CID:ä)
        local_questions = [
            q for q in questions_data.get('questions', []) 
            if q.get('ipfs_cid') is None and q.get('source') == 'local'
        ]
        
        if not local_questions:
            print("Ei uusia paikallisia kysymyksiä synkronoitavaksi")
            return None
        
        print(f"Löydetty {len(local_questions)} uutta paikallista kysymystä")
        
        # 3. Lataa nykyinen ipfs_questions.json
        ipfs_questions = self._load_json('ipfs_questions.json')
        
        # 4. Lisää uudet kysymykset ipfs_questions.json:iin
        for question in local_questions:
            # Generoi CID paikalliselle kysymykselle
            cid = self._generate_cid_for_question(question)
            question['ipfs_cid'] = cid
            question['source'] = 'local_synced'
            question['timestamps']['synced_to_ipfs'] = self._get_current_timestamp()
            
            # Lisää IPFS-kysymyksiin
            ipfs_questions.setdefault('questions', []).append(question)
        
        # 5. Päivitä ipfs_questions.json metadata
        ipfs_questions['metadata'] = {
            'local_system_id': self.local_system_id,
            'last_sync': self._get_current_timestamp(),
            'total_questions': len(ipfs_questions.get('questions', [])),
            'last_cid_batch': self._generate_cid_for_questions(ipfs_questions['questions'])
        }
        
        # 6. Tallenna ipfs_questions.json
        self._save_json('ipfs_questions.json', ipfs_questions)
        
        # 7. Päivitä questions.json CID:illä
        self._update_questions_with_cids(local_questions)
        
        # 8. Synkronoi ipfs_questions.json IPFS-verkkoon
        ipfs_cid = self._upload_to_ipfs(ipfs_questions)
        
        # 9. Päivitä meta.json
        self._update_meta_ipfs_reference('questions', ipfs_cid)
        
        print(f"Synkronoitu {len(local_questions)} uutta kysymystä IPFS:ään CID: {ipfs_cid}")
        return ipfs_cid
    
    def sync_ipfs_to_questions(self):
        """Synkronoi IPFS:stä tuodut kysymykset questions.json:iin"""
        print("=== IPFS_QUESTIONS.JSON → QUESTIONS.JSON SYNKRONOINTI ===")
        
        # 1. Hae viimeisin IPFS CID
        meta = self._load_json('meta.json')
        cid = meta.get('ipfs_references', {}).get('questions_latest')
        
        if not cid:
            print("Ei CID:ä saatavilla IPFS-synkronointiin")
            return None
        
        # 2. Lataa data IPFS:stä
        ipfs_data = self._download_from_ipfs(cid)
        
        if not ipfs_data:
            print("Ei dataa saatavilla IPFS:stä")
            return None
        
        # 3. Lataa paikallinen questions.json
        local_questions = self._load_json('questions.json')
        local_questions_map = {q['local_id']: q for q in local_questions.get('questions', [])}
        
        # 4. Suodata vain IPFS-kysymykset, joita ei vielä ole paikallisesti
        new_questions = []
        for ipfs_question in ipfs_data.get('questions', []):
            ipfs_cid = ipfs_question.get('ipfs_cid')
            local_id = ipfs_question.get('local_id')
            
            # Tarkista onko kysymys jo paikallisesti
            if local_id in local_questions_map:
                existing = local_questions_map[local_id]
                # Päivitä vain jos IPFS-versio on uudempi
                if (ipfs_question['timestamps']['synced_to_ipfs'] > 
                    existing['timestamps'].get('synced_to_ipfs', '1970-01-01')):
                    existing.update(ipfs_question)
            else:
                # Uusi kysymys IPFS:stä
                ipfs_question['source'] = 'ipfs_imported'
                ipfs_question['timestamps']['imported_from_ipfs'] = self._get_current_timestamp()
                new_questions.append(ipfs_question)
        
        # 5. Lisää uudet kysymykset paikalliseen questions.json:iin
        if new_questions:
            local_questions.setdefault('questions', []).extend(new_questions)
            local_questions['metadata']['last_updated'] = self._get_current_timestamp()
            local_questions['metadata']['last_ipfs_import'] = self._get_current_timestamp()
            
            # Tallenna päivitetty questions.json
            self._save_json('questions.json', local_questions)
            
            print(f"Tuotu {len(new_questions)} uutta kysymystä IPFS:stä")
        else:
            print("Ei uusia kysymyksiä IPFS:stä")
        
        return len(new_questions)
    
    def _update_questions_with_cids(self, questions_with_cids):
        """Päivittää questions.json tiedoston kysymyksiin CID:t"""
        questions_data = self._load_json('questions.json')
        questions_map = {q['local_id']: q for q in questions_data.get('questions', [])}
        
        for question in questions_with_cids:
            local_id = question['local_id']
            if local_id in questions_map:
                questions_map[local_id]['ipfs_cid'] = question['ipfs_cid']
                questions_map[local_id]['source'] = question['source']
                questions_map[local_id]['timestamps']['synced_to_ipfs'] = question['timestamps']['synced_to_ipfs']
        
        # Päivitä metadata
        questions_data['metadata']['last_updated'] = self._get_current_timestamp()
        questions_data['metadata']['last_sync'] = self._get_current_timestamp()
        questions_data['metadata']['sync_status']['ipfs_synced'] = True
        questions_data['metadata']['sync_status']['local_modified'] = False
        
        self._save_json('questions.json', questions_data)
    
    def _generate_cid_for_question(self, question):
        """Generoi CID:n yksittäiselle kysymykselle"""
        import hashlib
        question_string = json.dumps(question, sort_keys=True, ensure_ascii=False)
        return "Qm" + hashlib.sha256(question_string.encode('utf-8')).hexdigest()[:40]
    
    def _generate_cid_for_questions(self, questions):
        """Generoi CID:n kysymyskokoelmalle"""
        import hashlib
        questions_string = json.dumps(questions, sort_keys=True, ensure_ascii=False)
        return "Qm" + hashlib.sha256(questions_string.encode('utf-8')).hexdigest()[:40]
# complete_bidirectional_sync.py
class CompleteBidirectionalSync:
    def __init__(self, sync_manager):
        self.sync_manager = sync_manager
    
    def full_sync_cycle(self):
        """Suorittaa täydellisen kaksisuuntaisen synkronointisyklin"""
        print("=== ALKAA TÄYSI KAKSISUUNTAINEN SYNKRONOINTI ===")
        
        sync_results = {
            'local_to_ipfs': None,
            'ipfs_to_local': None,
            'timestamp': self.sync_manager._get_current_timestamp()
        }
        
        # 1. Synkronoi paikalliset kysymykset IPFS:ään
        try:
            sync_results['local_to_ipfs'] = self.sync_manager.sync_questions_to_ipfs()
        except Exception as e:
            print(f"Virhe paikallisesta IPFS:ään synkronoinnissa: {e}")
            sync_results['local_to_ipfs_error'] = str(e)
        
        # 2. Synkronoi IPFS:stä paikalliseen
        try:
            sync_results['ipfs_to_local'] = self.sync_manager.sync_ipfs_to_questions()
        except Exception as e:
            print(f"Virhe IPFS:stä paikalliseen synkronoinnissa: {e}")
            sync_results['ipfs_to_local_error'] = str(e)
        
        # 3. Päivitä system_chain
        self._update_system_chain(sync_results)
        
        # 4. Raportoi tilastoja
        self._report_sync_statistics(sync_results)
        
        print("=== KAKSISUUNTAINEN SYNKRONOINTI VALMIS ===")
        return sync_results
    
    def _update_system_chain(self, sync_results):
        """Päivittää system_chain.json synkronointitiedolla"""
        system_chain = self.sync_manager._load_json('system_chain.json')
        
        new_block = {
            "block_id": len(system_chain.get('blocks', [])),
            "timestamp": sync_results['timestamp'],
            "operation": "bidirectional_sync",
            "sync_results": sync_results,
            "files_affected": ["questions.json", "ipfs_questions.json"],
            "previous_hash": system_chain.get('blocks', [{}])[-1].get('block_hash', ''),
            "block_hash": self.sync_manager._generate_cid_for_questions([sync_results])
        }
        
        system_chain.setdefault('blocks', []).append(new_block)
        system_chain['current_state']['last_sync'] = sync_results['timestamp']
        system_chain['current_state']['questions_count'] = len(
            self.sync_manager._load_json('questions.json').get('questions', [])
        )
        
        self.sync_manager._save_json('system_chain.json', system_chain)
    
    def _report_sync_statistics(self, sync_results):
        """Raportoi synkronointitilastoja"""
        questions_data = self.sync_manager._load_json('questions.json')
        ipfs_questions_data = self.sync_manager._load_json('ipfs_questions.json')
        
        total_questions = len(questions_data.get('questions', []))
        local_questions = len([q for q in questions_data.get('questions', []) 
                             if q.get('source') in ['local', 'local_synced']])
        ipfs_questions = len([q for q in questions_data.get('questions', []) 
                            if q.get('source') == 'ipfs_imported'])
        
        print("\n=== SYNKRONOINTITILASTOT ===")
        print(f"Kysymyksiä yhteensä: {total_questions}")
        print(f"Paikallisia kysymyksiä: {local_questions}")
        print(f"IPFS:stä tuotuja kysymyksiä: {ipfs_questions}")
        print(f"IPFS:ään synkronoitu: {sync_results['local_to_ipfs'] is not None}")
        print(f"IPFS:stä tuotu: {sync_results['ipfs_to_local'] or 0} uutta kysymystä")
#!/usr/bin/env python3
#[file name]: create_install_config.py
#[file content begin]

"""
Vaalijärjestelmän konfiguraatiotiedostojen luontityökalu
Kysyy käyttäjältä tarvittavat tiedot ja luo asennustiedostot
"""

import json
import uuid
from datetime import datetime
from pathlib import Path
import sys

def get_input(prompt, default=None, required=True):
    """Kysyy käyttäjältä syötettä"""
    if default:
        prompt = f"{prompt} [{default}]: "
    else:
        prompt = f"{prompt}: "
    
    while True:
        value = input(prompt).strip()
        if not value and default:
            return default
        elif not value and required:
            print("❌ Tämä kenttä on pakollinen!")
        elif value:
            return value

def get_multilingual_input(field_name, languages=['fi', 'en', 'sv']):
    """Kysyy monikielistä tekstiä"""
    result = {}
    print(f"\n📝 Syötä {field_name} seuraavilla kielillä:")
    
    for lang in languages:
        lang_name = {
            'fi': 'suomeksi',
            'en': 'englanniksi', 
            'sv': 'ruotsiksi'
        }.get(lang, lang)
        
        result[lang] = get_input(f"  {lang_name}", required=True)
    
    return result

def get_date_input(prompt):
    """Kysyy päivämäärää varmistaen oikean muodon"""
    while True:
        date_str = get_input(prompt, required=True)
        try:
            # Tarkista että päivämäärä on oikeassa muodossa
            datetime.strptime(date_str, '%Y-%m-%d')
            return date_str
        except ValueError:
            print("❌ Virheellinen päivämäärämuoto! Käytä muotoa: YYYY-MM-DD")

def get_boolean_input(prompt, default=True):
    """Kysyy kyllä/ei -valintaa"""
    default_text = "Y" if default else "N"
    prompt = f"{prompt} (Y/N) [{default_text}]: "
    
    while True:
        value = input(prompt).strip().upper()
        if not value:
            return default
        elif value in ['Y', 'YES', 'K', 'KYLLÄ']:
            return True
        elif value in ['N', 'NO', 'E', 'EI']:
            return False
        else:
            print("❌ Syötä Y (kyllä) tai N (ei)")

def get_phases():
    """Kysyy vaalin vaiheet/päivät"""
    phases = []
    phase_count = int(get_input("Kuinka monta vaihetta/vaalipäivää vaalissa on", "1"))
    
    for i in range(phase_count):
        print(f"\n📅 Vaihe {i+1}:")
        phase = {
            "phase": i + 1,
            "date": get_date_input("  Vaalipäivä (YYYY-MM-DD)"),
            "description": get_multilingual_input("vaiheen kuvaus")
        }
        phases.append(phase)
    
    return phases

def create_election_config():
    """Luo vaalikonfiguraation käyttäjän syötteiden perusteella"""
    
    print("🎯 VAALIN PERUSTIEDOT")
    print("=" * 50)
    
    election_id = get_input("Vaalin yksilöllinen ID (esim. president_2024)")
    election_name = get_multilingual_input("vaalin nimi")
    election_description = get_multilingual_input("vaalin kuvaus")
    
    print("\n📊 VAALIN TYYPPI JA AJANKOHTA")
    election_type = get_input("Vaalityyppi", "presidential")
    phases = get_phases()
    
    print("\n⚙️  JÄRJESTELMÄASETUKSET")
    timelock_enabled = get_boolean_input("Käytetäänkö timelockia tuloksille", True)
    edit_deadline = get_date_input("Muokkausdeadline (YYYY-MM-DD)")
    grace_period = int(get_input("Grace period tunteina", "48"))
    community_managed = get_boolean_input("Yhteisöhallinnointi käytössä", True)
    
    print("\n🌍 VAIKUTUSALUE")
    districts_input = get_input("Vaalipiirit (pilkulla eroteltuna, 'koko_maa' koko maan vaaleissa)", "koko_maa")
    districts = [d.strip() for d in districts_input.split(',')]
    
    # Luo vaalikonfiguraatio
    election_config = {
        "election_id": election_id,
        "name": election_name,
        "description": election_description,
        "dates": phases,
        "type": election_type,
        "phases": len(phases),
        "timelock_enabled": timelock_enabled,
        "edit_deadline": edit_deadline,
        "grace_period_hours": grace_period,
        "community_managed": community_managed,
        "districts": districts,
        "candidate_count": None,  # Täytetään myöhemmin
        "status": "upcoming",
        "config_cid": f"QmConfig{uuid.uuid4().hex[:16]}",  # Mock-CID
        "created": datetime.now().isoformat()
    }
    
    return election_config

def create_install_config(election_config):
    """Luo install_config.base.json tiedoston"""
    
    install_config = {
        "election_data": {
            "id": election_config["election_id"],
            "ipfs_cid": election_config["config_cid"],
            "name": election_config["name"],
            "date": election_config["dates"][0]["date"],  # Ensimmäinen vaalipäivä
            "type": election_config["type"],
            "timelock_enabled": election_config["timelock_enabled"],
            "edit_deadline": election_config["edit_deadline"],
            "grace_period_hours": election_config["grace_period_hours"],
            "community_managed": election_config["community_managed"],
            "phases": election_config["phases"],
            "districts": election_config["districts"]
        },
        "community_governance": {
            "multisig_wallet": "{{MULTISIG_WALLET}}",
            "proposal_system": "{{PROPOSAL_SYSTEM_URL}}",
            "voting_contract": "{{VOTING_CONTRACT}}",
            "emergency_council": {
                "members": 5,
                "activation_threshold": 3
            }
        },
        "metadata": {
            "created": datetime.now().isoformat(),
            "version": "1.0.0",
            "generated_by": "create_install_config.py"
        }
    }
    
    return install_config

def create_meta_config(election_config):
    """Luo meta.base.json tiedoston"""
    
    meta_config = {
        "election": {
            "id": election_config["election_id"],
            "name": election_config["name"],
            "date": election_config["dates"][0]["date"],
            "type": election_config["type"],
            "timelock_enabled": election_config["timelock_enabled"],
            "edit_deadline": election_config["edit_deadline"],
            "grace_period_hours": election_config["grace_period_hours"],
            "governance_model": "community_driven"
        },
        "system_info": {
            "system_id": f"system_{election_config['election_id']}",
            "public_key": "{{SYSTEM_PUBLIC_KEY}}",
            "created": datetime.now().isoformat(),
            "governance_contract": "{{GOVERNANCE_CONTRACT_ADDRESS}}"
        },
        "community_governance": {
            "validators": [],
            "current_proposals": [],
            "voting_parameters": {
                "quorum": 15,
                "approval_threshold": 60
            }
        },
        "version": "1.0.0",
        "metadata": {
            "created": datetime.now().isoformat(),
            "config_source": "manual_creation"
        }
    }
    
    return meta_config

def create_elections_list(election_config):
    """Luo elections_list.json tiedoston"""
    
    elections_list = {
        "metadata": {
            "version": "1.0.0",
            "created": datetime.now().isoformat(),
            "last_updated": datetime.now().isoformat(),
            "ipfs_cid": f"QmElectionsList{uuid.uuid4().hex[:16]}",  # Mock-CID
            "description": {
                "fi": "Käsin luotu vaalilista",
                "en": "Manually created elections list", 
                "sv": "Manuellt skapad valista"
            }
        },
        "elections": [election_config],
        "election_types": {
            election_config["type"]: {
                "description": {
                    "fi": f"{election_config['name']['fi']} - tyyppi",
                    "en": f"{election_config['name']['en']} - type",
                    "sv": f"{election_config['name']['sv']} - typ"
                },
                "term_years": 4,  # Oletusarvo
                "max_terms": None
            }
        },
        "system_config": {
            "default_timelock_enabled": True,
            "default_grace_period_hours": 48,
            "default_community_managed": True,
            "supported_languages": ["fi", "en", "sv"],
            "version_control": True,
            "ipfs_backed": True
        }
    }
    
    return elections_list

def save_configs(election_config, output_dir="config_output"):
    """Tallentaa kaikki konfiguraatiotiedostot"""
    
    output_path = Path(output_dir)
    output_path.mkdir(exist_ok=True)
    
    # 1. Luo install_config.base.json
    install_config = create_install_config(election_config)
    install_file = output_path / "install_config.base.json"
    with open(install_file, 'w', encoding='utf-8') as f:
        json.dump(install_config, f, indent=2, ensure_ascii=False)
    print(f"✅ Luotu: {install_file}")
    
    # 2. Luo meta.base.json
    meta_config = create_meta_config(election_config)
    meta_file = output_path / "meta.base.json"
    with open(meta_file, 'w', encoding='utf-8') as f:
        json.dump(meta_config, f, indent=2, ensure_ascii=False)
    print(f"✅ Luotu: {meta_file}")
    
    # 3. Luo elections_list.json
    elections_list = create_elections_list(election_config)
    elections_file = output_path / "elections_list.json"
    with open(elections_file, 'w', encoding='utf-8') as f:
        json.dump(elections_list, f, indent=2, ensure_ascii=False)
    print(f"✅ Luotu: {elections_file}")
    
    # 4. Luo yksinkertainen system_chain.base.json
    system_chain = {
        "chain_id": election_config["election_id"],
        "created_at": datetime.now().isoformat(),
        "description": f"Vaalijärjestelmä ketju: {election_config['name']['fi']}",
        "version": "1.0.0",
        "blocks": [
            {
                "block_id": 0,
                "timestamp": datetime.now().isoformat(),
                "description": "Konfiguraation luonti",
                "files": {
                    "install_config.base.json": "{{HASH}}",
                    "meta.base.json": "{{HASH}}",
                    "elections_list.json": "{{HASH}}"
                },
                "previous_hash": None,
                "block_hash": "{{CREATION_HASH}}"
            }
        ],
        "current_state": {
            "election_id": election_config["election_id"],
            "election_name": election_config["name"]["fi"],
            "config_created": datetime.now().isoformat()
        },
        "metadata": {
            "algorithm": "sha256",
            "system_id": f"system_{election_config['election_id']}",
            "config_source": "manual_creation"
        }
    }
    
    system_chain_file = output_path / "system_chain.base.json"
    with open(system_chain_file, 'w', encoding='utf-8') as f:
        json.dump(system_chain, f, indent=2, ensure_ascii=False)
    print(f"✅ Luotu: {system_chain_file}")
    
    return output_path

def show_usage_instructions(election_config, output_dir):
    """Näyttää käyttöohjeet luotujen tiedostojen käyttöön"""
    
    print("\n" + "="*60)
    print("🎉 KONFIGURAATIOT LUOTU ONNISTUNEESTI!")
    print("="*60)
    
    print(f"\n📁 Tiedostot tallennettu hakemistoon: {output_dir}")
    print(f"🏛️  Vaali: {election_config['name']['fi']}")
    print(f"🆔 Vaali-ID: {election_config['election_id']}")
    
    print(f"\n🚀 ASENNA JÄRJESTELMÄ:")
    print(f"python install.py --config-file={output_dir}/elections_list.json --election-id={election_config['election_id']} --first-install")
    
    print(f"\n💡 VAIHTOEHTOISET ASENNUSTAVAT:")
    print(f"# 1. Käytä suoraan install_configia:")
    print(f"python install.py --config-file={output_dir}/install_config.base.json --election-id={election_config['election_id']} --first-install")
    
    print(f"\n# 2. Asenna ilman first-install lippua (lisäkoneet):")
    print(f"python install.py --config-file={output_dir}/elections_list.json --election-id={election_config['election_id']}")
    
    print(f"\n# 3. Tarkista asennus:")
    print(f"python install.py --config-file={output_dir}/elections_list.json --election-id={election_config['election_id']} --verify")
    
    print(f"\n📋 LUODUT TIEDOSTOT:")
    for file in Path(output_dir).glob("*.json"):
        print(f"   📄 {file.name}")
    
    print(f"\n⚠️  HUOMIOITAVAA:")
    print("   - Korvaa {{MULTISIG_WALLET}} ja muut placeholderit oikeilla arvoilla")
    print("   - Tarkista erityisesti päivämäärät")
    print("   - Testaa aina asennus ennen tuotantokäyttöä")

def main():
    """Pääohjelma"""
    
    print("🎯 VAAILIJÄRJESTELMÄN KONFIGURAATION LUONTI")
    print("=" * 60)
    print("Tämä työkalu luo vaalijärjestelmälle tarvittavat konfiguraatiotiedostot")
    print("Vastaa seuraaviin kysymyksiin luodaksesi vaalin konfiguraation\n")
    
    try:
        # 1. Luo vaalikonfiguraatio
        election_config = create_election_config()
        
        # 2. Kysy tallennushakemisto
        output_dir = get_input("Tallennushakemisto", "config_output")
        
        # 3. Tallenna konfiguraatiot
        saved_path = save_configs(election_config, output_dir)
        
        # 4. Näytä käyttöohjeet
        show_usage_instructions(election_config, output_dir)
        
        print(f"\n✅ VALMIS! Järjestelmä on nyt valmis asennettavaksi.")
        
    except KeyboardInterrupt:
        print("\n\n❌ Konfiguraation luonti keskeytetty")
        sys.exit(1)
    except Exception as e:
        print(f"\n❌ Virhe konfiguraation luonnissa: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
#[file content end]
# demo_cid_sync.py
def demonstrate_cid_sync_workflow():
    """Demonstroi CID-pohjaista synkronointityökulkua"""
    
    # Alusta synkronointimanageri
    sync_manager = CIDSyncManager()
    bidir_sync = CompleteBidirectionalSync(sync_manager)
    
    print(f"Paikallinen järjestelmä ID: {sync_manager.local_system_id}")
    
    # 1. Lisää uusi paikallinen kysymys (ilman CID:ä)
    question_data = {
        "local_id": sync_manager._generate_local_id(),
        "ipfs_cid": None,
        "source": "local",
        "global_version": 1,
        "timestamps": {
            "created_local": sync_manager._get_current_timestamp(),
            "modified_local": sync_manager._get_current_timestamp(),
            "synced_to_ipfs": None,
            "imported_from_ipfs": None
        },
        "content": {
            "category": {"fi": "Testi", "en": "Test", "sv": "Test"},
            "question": {"fi": "Uusi paikallinen kysymys?", "en": "New local question?", "sv": "Ny lokal fråga?"},
            "tags": ["test", "local"],
            "scale": {"min": -5, "max": 5}
        },
        "elo_rating": {
            "base_rating": 1000,
            "comparison_delta": 0,
            "vote_delta": 0,
            "current_rating": 1000
        }
    }
    
    # Lisää questions.json:iin
    questions_data = sync_manager._load_json('questions.json')
    questions_data.setdefault('questions', []).append(question_data)
    questions_data['metadata']['last_updated'] = sync_manager._get_current_timestamp()
    questions_data['metadata']['sync_status']['local_modified'] = True
    sync_manager._save_json('questions.json', questions_data)
    
    print(f"Lisätty uusi paikallinen kysymys: {question_data['local_id']}")
    print(f"Kysymyksen CID aluksi: {question_data['ipfs_cid']}")
    
    # 2. Suorita kaksisuuntainen synkronointi
    sync_results = bidir_sync.full_sync_cycle()
    
    # 3. Tarkista että kysymys sai CID:n
    updated_questions = sync_manager._load_json('questions.json')
    updated_question = next(
        (q for q in updated_questions['questions'] 
         if q['local_id'] == question_data['local_id']), 
        None
    )
    
    if updated_question and updated_question['ipfs_cid']:
        print(f"Kysymys sai CID:n: {updated_question['ipfs_cid']}")
        print(f"Lähde: {updated_question['source']}")
    else:
        print("Kysymys ei saanut CID:ä")
    
    # 4. Simuloi toisen laitteen synkronointia
    print("\n--- Simuloidaan toisen laitteen IPFS-synkronointia ---")
    
    # Toinen laite lataa samat kysymykset IPFS:stä
    ipfs_results = sync_manager.sync_ipfs_to_questions()
    
    print(f"Toinen laite tuonut {ipfs_results} uutta kysymystä IPFS:stä")

if __name__ == "__main__":
    demonstrate_cid_sync_workflow()
# example_usage.py
def example_candidate_workflow():
    """Esimerkki ehdokkaan lisäyksestä ja vastausten antamisesta"""
    manager = UnifiedSyncManager()
    
    # 1. Lisää uusi ehdokas
    candidate_data = {
        "basic_info": {
            "name": {
                "fi": "Matti Meikäläinen",
                "en": "Matti Meikalainen", 
                "sv": "Matti Meikalainen"
            },
            "party": "green_party",
            "district": "helsinki",
            "photo_url": "https://example.com/matti.jpg",
            "contact_info": {
                "email": "matti@example.com",
                "website": "https://matti.example.com"
            }
        },
        "answers": []  # Aluksi tyhjä
    }
    
    # 2. Määrittele vastaukset
    candidate_answers = [
        {
            "question_id": 1,
            "answer_value": 4,
            "explanation": {
                "fi": "Polkupyöräily on tärkeä osa kestävää liikennettä",
                "en": "Cycling is an important part of sustainable transport",
                "sv": "Cykling är en viktig del av hållbar transport"
            },
            "confidence": 4
        },
        {
            "question_id": 2, 
            "answer_value": -2,
            "explanation": {
                "fi": "Jätän varauksella, koska asia on monimutkainen",
                "en": "I'm cautious because the issue is complex",
                "sv": "Jag är försiktig eftersom frågan är komplex"
            },
            "confidence": 3
        }
    ]
    
    # 3. Lisää ehdokas vastauksineen
    candidate_id = manager.add_candidate_with_answers(candidate_data, candidate_answers)
    
    print(f"Ehdokas {candidate_id} lisätty onnistuneesti")
    
    # 4. Suorita synkronointi
    manager.full_sync_cycle()
    
    return candidate_id

# Suorita esimerkki
if __name__ == "__main__":
    example_candidate_workflow()
# initialization.py
import json
import shutil
from datetime import datetime

class FileInitializer:
    def __init__(self, base_dir="base_templates", runtime_dir="runtime"):
        self.base_dir = base_dir
        self.runtime_dir = runtime_dir
        
    def initialize_runtime_files(self):
        """Kloonaa base-tiedostot runtime-kansioon"""
        base_files = [
            'questions.base.json', 'meta.base.json', 'governance.base.json',
            'community.base.json', 'install_config.base.json', 
            'system_chain.base.json', 'ipfs.base.json', 'ipfs_conf.base.json'
        ]
        
        for base_file in base_files:
            runtime_file = base_file.replace('.base.json', '.json')
            source_path = f"{self.base_dir}/{base_file}"
            target_path = f"{self.runtime_dir}/{runtime_file}"
            
            # Kloonaa base -> runtime
            shutil.copy2(source_path, target_path)
            print(f"Kloonattu: {source_path} -> {target_path}")
            
        # Alusta tyhjät runtime-tiedostot
        self.initialize_empty_runtime_files()
        
    def initialize_empty_runtime_files(self):
        """Alusta tyhjät runtime-tiedostot"""
        empty_files = [
            'new_questions.json',
            'active_questions.json', 
            'ipfs_questions.json',
            'parties.json',
            'party_profiles.json',
            'candidates.json',
            'candidate_profiles.json'
        ]
        
        for file in empty_files:
            file_path = f"{self.runtime_dir}/{file}"
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump({
                    "metadata": {
                        "created": datetime.now().isoformat(),
                        "version": "1.0.0",
                        "source": "empty_initialization"
                    },
                    "data": []
                }, f, indent=2, ensure_ascii=False)
            
            print(f"Alustettu tyhjä: {file_path}")

# Käyttö
initializer = FileInitializer()
initializer.initialize_runtime_files()
"""
Asennusmoottori vaalijärjestelmälle - KORJATTU VERSIO
Käsittelee asennuslogiikan modulaarisesti sekä IPFS:n että paikalliset tiedostot
"""

import json
import sys
from pathlib import Path
from typing import Dict, Any, Optional
from datetime import datetime

from metadata_manager import get_metadata_manager

class InstallationEngine:
    """Käsittelee vaalijärjestelmän asennuslogiikan"""
    
    def __init__(self, runtime_dir: str = "runtime"):
        self.runtime_dir = Path(runtime_dir)
        self.metadata_manager = get_metadata_manager(runtime_dir)
        self.ipfs_client = None  # Asetetaan ulkopuolelta
    
    def set_ipfs_client(self, ipfs_client):
        """Asettaa IPFS-asiakkaan"""
        self.ipfs_client = ipfs_client
    
    def load_elections_config(self, config_source: str) -> Dict[str, Any]:
        """Lataa vaalikonfiguraation joko IPFS:stä tai paikallisesta tiedostosta"""
        
        # Tarkista onko lähde paikallinen tiedosto
        if config_source.endswith('.json') and Path(config_source).exists():
            print(f"📁 Ladataan paikallisesta tiedostosta: {config_source}")
            return self._load_from_local_file(config_source)
        
        # Tarkista onko lähde IPFS CID
        elif config_source.startswith('Qm') and self.ipfs_client:
            print(f"🌐 Ladataan IPFS:stä CID:llä: {config_source}")
            return self._load_from_ipfs(config_source)
        
        else:
            raise ValueError(f"Tuntematon konfiguraatiolähde: {config_source}")
    
    def _load_from_local_file(self, file_path: str) -> Dict[str, Any]:
        """Lataa konfiguraatio paikallisesta tiedostosta"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
                
            # Tarkista tiedoston rakenne
            if 'elections' in data:
                # elections_list.json rakenne
                return data
            elif 'election_data' in data:
                # install_config.base.json rakenne - muunna elections_list muotoon
                return self._convert_install_config_to_elections_list(data)
            else:
                raise ValueError("Tuntematon konfiguraatiotiedoston rakenne")
                
        except Exception as e:
            raise ValueError(f"Virhe ladattaessa tiedostoa {file_path}: {e}")
    
    def _load_from_ipfs(self, cid: str) -> Dict[str, Any]:
        """Lataa konfiguraatio IPFS:stä"""
        if not self.ipfs_client:
            raise ValueError("IPFS-asiakas puuttuu")
        
        elections_data = self.ipfs_client.download(cid)
        
        if not elections_data:
            raise ValueError(f"Vaalikonfiguraatiota ei löydy CID:llä: {cid}")
        
        return elections_data
    
    def _convert_install_config_to_elections_list(self, install_config: Dict[str, Any]) -> Dict[str, Any]:
        """Muuntaa install_config.base.json muotoon elections_list.json"""
        election_data = install_config['election_data']
        
        return {
            "metadata": {
                "version": "1.0.0",
                "created": datetime.now().isoformat(),
                "source": "converted_from_install_config"
            },
            "elections": [
                {
                    "election_id": election_data["id"],
                    "name": election_data["name"],
                    "description": election_data["name"],  # Käytä nimea kuvauksena
                    "dates": [
                        {
                            "phase": 1,
                            "date": election_data["date"],
                            "description": {
                                "fi": "Vaalipäivä",
                                "en": "Election day",
                                "sv": "Valdag"
                            }
                        }
                    ],
                    "type": election_data["type"],
                    "timelock_enabled": election_data["timelock_enabled"],
                    "edit_deadline": election_data["edit_deadline"],
                    "grace_period_hours": election_data["grace_period_hours"],
                    "community_managed": election_data["community_managed"],
                    "phases": 1,
                    "districts": election_data.get("districts", ["koko_maa"]),
                    "status": "upcoming",
                    "config_cid": election_data.get("ipfs_cid", "")
                }
            ]
        }
    
    def list_available_elections(self, elections_data: Dict[str, Any]) -> None:
        """Listaa saatavilla olevat vaalit"""
        print("\n📋 SAATAVILLA OLEVAT VAALIT:")
        print("=" * 70)
        
        for i, election in enumerate(elections_data['elections'], 1):
            status = election.get('status', 'unknown')
            dates = ", ".join([phase['date'] for phase in election['dates']])
            election_id = election['election_id']
            
            # Tarkista asennustila
            machine_info = self.metadata_manager.get_machine_info()
            is_installed = (machine_info['election_id'] == election_id)
            install_status = "✅ ASENNETTU" if is_installed else "🔲 EI ASENNETTU"
            
            print(f"{i}. {election['name']['fi']} {install_status}")
            print(f"   🆔 ID: {election_id}")
            print(f"   📅 Päivät: {dates}")
            print(f"   🏛️  Tyyppi: {election['type']}")
            print(f"   📊 Tila: {status}")
            print(f"   🔗 Konfiguraatio CID: {election.get('config_cid', 'Ei määritelty')}")
            print()
    
    def install_election(self, election_id: str, elections_data: Dict[str, Any], 
                        first_install: bool = False) -> Dict[str, Any]:
        """Asentaa tietyn vaalin"""
        
        # Etsi vaali
        election = self._find_election(election_id, elections_data)
        if not election:
            raise ValueError(f"Vaalia '{election_id}' ei löydy")
        
        print(f"🚀 ASENNETAAN VAALI: {election['name']['fi']}")
        
        # 1. Alusta metadata
        metadata = self.metadata_manager.initialize_system_metadata(election_id, first_install)
        machine_info = self.metadata_manager.get_machine_info()
        
        print(f"   💻 Kone-ID: {machine_info['machine_id']}")
        print(f"   📝 Asennustyyppi: {'Ensimmäinen asennus' if first_install else 'Lisäasennus'}")
        
        # 2. Lataa vaalin spesifinen konfiguraatio jos saatavilla
        election_config = self._load_election_config(election)
        
        # 3. Luo konfiguraatiotiedostot
        self._create_configuration_files(election, election_config, first_install)
        
        # 4. Luo vaalirekisteri ensimmäiselle asennukselle
        if first_install:
            registry = self.metadata_manager.create_election_registry(election)
            self._save_election_registry(registry)
        
        # 5. Päivitä system_chain
        self._update_system_chain(election, machine_info)
        
        return {
            "election": election,
            "metadata": metadata,
            "machine_info": machine_info,
            "installation_time": datetime.now().isoformat()
        }
    
    def _find_election(self, election_id: str, elections_data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Etsii vaalin ID:llä"""
        for election in elections_data['elections']:
            if election['election_id'] == election_id:
                return election
        return None
    
    def _load_election_config(self, election: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Lataa vaalin spesifinen konfiguraatio"""
        config_cid = election.get('config_cid')
        if config_cid and self.ipfs_client:
            print(f"   🔍 Ladataan vaalin spesifistä konfiguraatiota...")
            return self.ipfs_client.download(config_cid)
        return None
    
    def _create_configuration_files(self, election: Dict[str, Any], 
                                  election_config: Optional[Dict[str, Any]], 
                                  first_install: bool):
        """Luo konfiguraatiotiedostot"""
        
        # Luo base-templatet
        self._create_base_templates(election, election_config)
        
        # Luo runtime-tiedostot
        self._create_runtime_files(election)
        
        # Luo asennusmetatiedot
        self._create_installation_meta(election, first_install)
        
        print(f"   ✅ Konfiguraatiotiedostot luotu")
    
    def _create_base_templates(self, election: Dict[str, Any], election_config: Optional[Dict[str, Any]]):
        """Luo base-template tiedostot"""
        base_dir = self.runtime_dir / "base_templates"
        base_dir.mkdir(exist_ok=True)
        
        # install_config.base.json
        install_config = {
            "election_data": {
                "id": election["election_id"],
                "ipfs_cid": election.get("config_cid", ""),
                "name": election["name"],
                "date": election["dates"][0]["date"],
                "type": election["type"],
                "timelock_enabled": election["timelock_enabled"],
                "edit_deadline": election["edit_deadline"],
                "grace_period_hours": election["grace_period_hours"],
                "community_managed": election["community_managed"],
                "phases": election.get("phases", 1),
                "districts": election.get("districts", [])
            },
            "system_metadata": {
                "machine_id": self.metadata_manager.get_machine_info()["machine_id"],
                "first_install": self.metadata_manager.get_machine_info()["first_install"],
                "installed_at": datetime.now().isoformat()
            }
        }
        
        with open(base_dir / "install_config.base.json", "w", encoding="utf-8") as f:
            json.dump(install_config, f, indent=2, ensure_ascii=False)
    
    def _create_runtime_files(self, election: Dict[str, Any]):
        """Luo runtime-tiedostot"""
        runtime_files = {
            "questions.json": {
                "metadata": {
                    "election_id": election["election_id"],
                    "machine_id": self.metadata_manager.get_machine_info()["machine_id"],
                    "created": datetime.now().isoformat()
                },
                "questions": []
            },
            "candidates.json": {
                "metadata": {
                    "election_id": election["election_id"],
                    "machine_id": self.metadata_manager.get_machine_info()["machine_id"],
                    "created": datetime.now().isoformat()
                },
                "candidates": []
            },
            "new_questions.json": {
                "metadata": {
                    "election_id": election["election_id"],
                    "created": datetime.now().isoformat()
                },
                "questions": []
            },
            "active_questions.json": {
                "metadata": {
                    "election_id": election["election_id"],
                    "created": datetime.now().isoformat()
                },
                "questions": []
            },
            "ipfs_questions.json": {
                "metadata": {
                    "election_id": election["election_id"],
                    "created": datetime.now().isoformat(),
                    "last_sync": None
                },
                "questions": []
            }
        }
        
        for filename, content in runtime_files.items():
            with open(self.runtime_dir / filename, "w", encoding="utf-8") as f:
                json.dump(content, f, indent=2, ensure_ascii=False)
    
    def _create_installation_meta(self, election: Dict[str, Any], first_install: bool):
        """Luo asennusmetatiedot"""
        installation_meta = {
            "installation": {
                "election_id": election["election_id"],
                "election_name": election["name"]["fi"],
                "machine_id": self.metadata_manager.get_machine_info()["machine_id"],
                "first_install": first_install,
                "installed_at": datetime.now().isoformat(),
                "system_version": "1.0.0"
            }
        }
        
        with open(self.runtime_dir / "installation_meta.json", "w", encoding="utf-8") as f:
            json.dump(installation_meta, f, indent=2, ensure_ascii=False)
    
    def _save_election_registry(self, registry: Dict[str, Any]):
        """Tallentaa vaalirekisterin"""
        with open(self.runtime_dir / "election_registry.json", "w", encoding="utf-8") as f:
            json.dump(registry, f, indent=2, ensure_ascii=False)
    
    def _update_system_chain(self, election: Dict[str, Any], machine_info: Dict[str, Any]):
        """Päivittää system_chain.json"""
        system_chain = {
            "chain_id": election["election_id"],
            "machine_id": machine_info["machine_id"],
            "created_at": datetime.now().isoformat(),
            "description": f"Vaalijärjestelmä: {election['name']['fi']}",
            "installation_type": "first" if machine_info["first_install"] else "additional",
            "blocks": [
                {
                    "block_id": 0,
                    "timestamp": datetime.now().isoformat(),
                    "description": "Järjestelmän asennus",
                    "machine_id": machine_info["machine_id"],
                    "first_install": machine_info["first_install"]
                }
            ],
            "current_state": {
                "election_id": election["election_id"],
                "installation_time": datetime.now().isoformat(),
                "files_created": [
                    "install_config.base.json",
                    "questions.json", 
                    "candidates.json",
                    "system_chain.json",
                    "installation_meta.json"
                ]
            }
        }
        
        with open(self.runtime_dir / "system_chain.json", "w", encoding="utf-8") as f:
            json.dump(system_chain, f, indent=2, ensure_ascii=False)
    
    def verify_installation(self, election_id: str) -> bool:
        """Tarkistaa asennuksen onnistumisen"""
        required_files = [
            "base_templates/install_config.base.json",
            "questions.json",
            "candidates.json", 
            "system_chain.json",
            "installation_meta.json",
            "new_questions.json",
            "active_questions.json",
            "ipfs_questions.json"
        ]
        
        for file_path in required_files:
            if not (self.runtime_dir / file_path).exists():
                print(f"❌ Puuttuu: {file_path}")
                return False
        
        # Tarkista että metadata on oikealle vaalille
        machine_info = self.metadata_manager.get_machine_info()
        if machine_info["election_id"] != election_id:
            print(f"❌ Väärä vaali: {machine_info['election_id']} != {election_id}")
            return False
        
        print("✅ Asennus tarkistettu onnistuneesti")
        return True

[file name]: installation_engine_sync.py
[file content begin]
"""
Päivitetty asennusmoottori IPFS-synkronointia varten
"""

from installation_engine import InstallationEngine
from ipfs_sync_engine import get_ipfs_sync_engine
from mock_ipfs_sync_ready import MockIPFSSyncReady

class InstallationEngineWithSync(InstallationEngine):
    """Asennusmoottori IPFS-synkronointituelle"""
    
    def __init__(self, runtime_dir: str = "runtime", enable_sync: bool = False):
        super().__init__(runtime_dir)
        
        # Käytä synkronointivalmista mock-IPFS:ää
        self.mock_ipfs = MockIPFSSyncReady()
        
        # Alusta synkronointimoottori
        self.sync_engine = get_ipfs_sync_engine(self.mock_ipfs)
        
        # Ota synkronointi käyttöön jos haluttu
        if enable_sync:
            try:
                self.sync_engine.enable_sync("hybrid")
                print("✅ IPFS-synkronointi käytössä hybrid-tilassa")
            except Exception as e:
                print(f"⚠️  Synkronointi ei saatavilla: {e}")
        
        # Aseta synkronointimoottori IPFS-asiakkaaksi
        self.ipfs_client = self.sync_engine
    
    def set_sync_mode(self, mode: str):
        """Aseta synkronointitila"""
        valid_modes = ["mock_only", "hybrid", "real_only"]
        if mode not in valid_modes:
            raise ValueError(f"Virheellinen tila: {mode}")
        
        self.sync_engine.enable_sync(mode)
        print(f"✅ Synkronointitila asetettu: {mode}")
    
    def get_sync_status(self):
        """Hae synkronointitila"""
        return self.sync_engine.get_sync_status()
    
    def migrate_to_real_ipfs(self):
        """Siirrä oikeaan IPFS:ään"""
        return self.sync_engine.migrate_to_real_only()
    
    def sync_all_data(self):
        """Synkronoi kaikki data mock -> real"""
        return self.sync_engine.sync_all_mock_to_real()
#!/usr/bin/env python3
"""
Vaalijärjestelmän modulaarinen asennusskripti - KORJATTU VERSIO
Käyttö: 
  python install.py --config-file=CID/TIEDOSTO --election-id=ID [--first-install] [--output-dir=DIR]
"""

import argparse
import sys
import json
from pathlib import Path
from datetime import datetime

# Lisää moduulit polkuun
sys.path.append('.')

try:
    from metadata_manager import get_metadata_manager
    from installation_engine import InstallationEngine
except ImportError as e:
    print(f"Moduulien latausvirhe: {e}")
    sys.exit(1)

# Yksinkertainen MockIPFS korvaaja jos ei saatavilla
class SimpleMockIPFS:
    """Yksinkertainen Mock-IPFS paikallisille tiedostoille"""
    
    def download(self, cid_or_path):
        """Lataa dataa - tukea paikallisille tiedostoille"""
        if cid_or_path.endswith('.json') and Path(cid_or_path).exists():
            # Lataa paikallisesta tiedostosta
            try:
                with open(cid_or_path, 'r', encoding='utf-8') as f:
                    return json.load(f)
            except Exception as e:
                print(f"❌ Virhe ladattaessa tiedostoa {cid_or_path}: {e}")
                return None
        else:
            print(f"⚠️  IPFS-toiminto ei saatavilla, käytetään paikallisia tiedostoja")
            return None
    
    def upload(self, data):
        """Mock-upload - palauttaa mock-CID:n"""
        import hashlib
        content_string = json.dumps(data, sort_keys=True, ensure_ascii=False)
        content_hash = hashlib.sha256(content_string.encode('utf-8')).hexdigest()
        return f"QmMock{content_hash[:40]}"

def load_elections_config_direct(file_path: str) -> dict:
    """Lataa vaalikonfiguraatio suoraan tiedostosta"""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        # Tarkista tiedoston rakenne
        if 'elections' in data:
            # elections_list.json rakenne
            return data
        elif 'election_data' in data:
            # install_config.base.json rakenne - muunna elections_list muotoon
            return convert_install_config_to_elections_list(data)
        else:
            raise ValueError("Tuntematon konfiguraatiotiedoston rakenne")
            
    except Exception as e:
        raise ValueError(f"Virhe ladattaessa tiedostoa {file_path}: {e}")

def convert_install_config_to_elections_list(install_config: dict) -> dict:
    """Muuntaa install_config.base.json muotoon elections_list.json"""
    election_data = install_config['election_data']
    
    return {
        "metadata": {
            "version": "1.0.0",
            "created": datetime.now().isoformat(),
            "source": "converted_from_install_config"
        },
        "elections": [
            {
                "election_id": election_data["id"],
                "name": election_data["name"],
                "description": election_data["name"],  # Käytä nimeä kuvauksena
                "dates": [
                    {
                        "phase": 1,
                        "date": election_data["date"],
                        "description": {
                            "fi": "Vaalipäivä",
                            "en": "Election day",
                            "sv": "Valdag"
                        }
                    }
                ],
                "type": election_data["type"],
                "timelock_enabled": election_data["timelock_enabled"],
                "edit_deadline": election_data["edit_deadline"],
                "grace_period_hours": election_data["grace_period_hours"],
                "community_managed": election_data["community_managed"],
                "phases": 1,
                "districts": election_data.get("districts", ["koko_maa"]),
                "status": "upcoming",
                "config_cid": election_data.get("ipfs_cid", "")
            }
        ]
    }

def main():
    parser = argparse.ArgumentParser(
        description="Vaalijärjestelmän modulaarinen asennus",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Esimerkkejä:
  # Käytä paikallista elections_list.json tiedostoa
  python install.py --config-file=config_output/elections_list.json --election-id=Testivaalit_2027 --first-install
  
  # Käytä paikallista install_config.base.json tiedostoa
  python install.py --config-file=config_output/install_config.base.json --election-id=Testivaalit_2027 --first-install
        """
    )
    
    parser.add_argument(
        "--config-file", 
        required=True,
        help="Polku paikalliseen JSON-tiedostoon"
    )
    parser.add_argument(
        "--election-id", 
        help="Tietyn vaalin ID asennettuna (lista näytetään jos ei anneta)"
    )
    parser.add_argument(
        "--output-dir", 
        default="runtime",
        help="Output-hakemisto (oletus: runtime)"
    )
    parser.add_argument(
        "--first-install", 
        action="store_true",
        help="Merkitse ensimmäiseksi asennukseksi (luo master-kone)"
    )
    parser.add_argument(
        "--list-elections", 
        action="store_true",
        help="Listaa saatavilla olevat vaalit"
    )
    parser.add_argument(
        "--verify", 
        action="store_true",
        help="Tarkista nykyinen asennus"
    )
    
    args = parser.parse_args()
    
    # Tarkista että config-file on olemassa
    if not Path(args.config_file).exists():
        print(f"❌ Tiedostoa ei löydy: {args.config_file}")
        sys.exit(1)
    
    # Alusta komponentit
    engine = InstallationEngine(args.output_dir)
    engine.set_ipfs_client(SimpleMockIPFS())  # Yksinkertainen mock-IPFS
    
    try:
        # Lataa vaalikonfiguraatio SUORAAN tiedostosta
        print(f"📁 Ladataan konfiguraatiota tiedostosta: {args.config_file}")
        elections_data = load_elections_config_direct(args.config_file)
        
        if args.list_elections:
            engine.list_available_elections(elections_data)
            return
        
        if args.verify:
            if not args.election_id:
                print("Virhe: --election-id vaaditaan verifiointiin")
                return
            
            if engine.verify_installation(args.election_id):
                machine_info = get_metadata_manager(args.output_dir).get_machine_info()
                print(f"✅ ASENNUS OK")
                print(f"   Vaali: {args.election_id}")
                print(f"   Kone-ID: {machine_info['machine_id']}")
                print(f"   Master-kone: {'✅' if machine_info['is_master'] else '❌'}")
            else:
                print("❌ ASENNUS VIRHEELLINEN TAI KESKEN")
            return
        
        if not args.election_id:
            engine.list_available_elections(elections_data)
            print("\n💡 Käytä --election-id=<id> asentaaksesi tietyn vaalin")
            print("💡 Käytä --first-install ensimmäiselle asennukselle")
            return
        
        # Tarkista first-install logiikka
        metadata_manager = get_metadata_manager(args.output_dir)
        is_first = metadata_manager.is_first_installation(args.election_id)
        
        if args.first_install and not is_first:
            print("⚠️  VAROITUS: --first-install asetettu, mutta vaali on jo asennettu")
            print("   Käytetään olemassa olevaa asennusta")
            args.first_install = False
        elif not args.first_install and is_first:
            print("💡 INFO: Ensimmäinen asennus tälle vaalille")
            print("   Käytetään --first-install lippua luodaksesi master-kone")
            args.first_install = True
        
        # Suorita asennus
        result = engine.install_election(
            args.election_id, 
            elections_data, 
            args.first_install
        )
        
        # Näytä loppuraportti
        election = result["election"]
        machine_info = result["machine_info"]
        
        print("\n🎉 ASENNUS VALMIS!")
        print("=" * 50)
        print(f"Vaali: {election['name']['fi']}")
        print(f"Kone-ID: {machine_info['machine_id']}")
        print(f"Asennustyyppi: {'Master-kone' if machine_info['is_master'] else 'Työasema'}")
        print(f"Hakemisto: {args.output_dir}")
        print(f"Asennettu: {result['installation_time']}")
        
        if machine_info['is_master']:
            print("\n🔑 Olet nyt MASTER-KONE tälle vaalille")
            print("   Muut koneet voivat liittyä tähän vaaliin")
        else:
            print("\n💻 Olet nyt TYÖASEMA tälle vaalille")
            print("   Synkronoi data master-koneen kanssa")
            
    except Exception as e:
        print(f"❌ ASENNUS EPÄONNISTUI: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()

[file name]: ipfs_sync_engine.py
[file content begin]
"""
IPFS synkronointimoottori mock-IPFS:n ja oikean IPFS:n välille
Mahdollistaa siirtymisen mock -> production
"""

import json
import hashlib
from datetime import datetime
from pathlib import Path
from typing import Dict, Any, List, Optional
import tempfile
import os

try:
    import ipfshttpclient
    REAL_IPFS_AVAILABLE = True
except ImportError:
    REAL_IPFS_AVAILABLE = False
    print("⚠️  ipfshttpclient ei saatavilla, oikea IPFS pois käytöstä")

class RealIPFS:
    """Oikea IPFS-asiakas py-ipfs-http-client:lla"""
    
    def __init__(self, host: str = '/ip4/127.0.0.1/tcp/5001'):
        if not REAL_IPFS_AVAILABLE:
            raise ImportError("ipfshttpclient ei asennettu")
        
        try:
            self.client = ipfshttpclient.connect(host)
            self.connected = True
            print(f"✅ Yhdistetty oikeaan IPFS:ään: {host}")
        except Exception as e:
            self.connected = False
            print(f"❌ IPFS-yhteysvirhe: {e}")
            raise
    
    def upload(self, data: Dict[str, Any]) -> str:
        """Lähetä data oikeaan IPFS:ään"""
        if not self.connected:
            raise ConnectionError("IPFS-yhteys katkaistu")
        
        # Kirjoita data väliaikaiseen tiedostoon
        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
            temp_path = f.name
        
        try:
            # Lähetä IPFS:ään
            result = self.client.add(temp_path)
            cid = result['Hash']
            
            # Pinnaa data pysyväksi
            self.client.pin.add(cid)
            
            print(f"✅ Lähetetty oikeaan IPFS:ään - CID: {cid}")
            return cid
        except Exception as e:
            print(f"❌ IPFS-upload virhe: {e}")
            raise
        finally:
            # Siivoa väliaikainen tiedosto
            os.unlink(temp_path)
    
    def download(self, cid: str) -> Optional[Dict[str, Any]]:
        """Lataa data oikeasta IPFS:stä"""
        if not self.connected:
            raise ConnectionError("IPFS-yhteys katkaistu")
        
        try:
            # Hae data IPFS:stä
            content = self.client.cat(cid)
            data = json.loads(content.decode('utf-8'))
            
            print(f"✅ Ladattu oikeasta IPFS:stä - CID: {cid}")
            return data
        except Exception as e:
            print(f"❌ IPFS-download virhe CID:llä {cid}: {e}")
            return None
    
    def pin(self, cid: str) -> bool:
        """Pinnaa data oikeassa IPFS:ässä"""
        if not self.connected:
            return False
        
        try:
            self.client.pin.add(cid)
            print(f"✅ Pinnattu oikeassa IPFS:ässä - CID: {cid}")
            return True
        except Exception as e:
            print(f"❌ Pin-virhe: {e}")
            return False
    
    def unpin(self, cid: str) -> bool:
        """Poista pinnaus oikeasta IPFS:stä"""
        if not self.connected:
            return False
        
        try:
            self.client.pin.rm(cid)
            print(f"✅ Poistettu pinnaus - CID: {cid}")
            return True
        except Exception as e:
            print(f"❌ Unpin-virhe: {e}")
            return False
    
    def get_stats(self) -> Dict[str, Any]:
        """Hae tilastot oikeasta IPFS:stä"""
        if not self.connected:
            return {"connected": False}
        
        try:
            # Yksinkertaiset tilastot
            id_info = self.client.id()
            return {
                "connected": True,
                "peer_id": id_info['ID'],
                "agent_version": id_info['AgentVersion'],
                "protocol_version": id_info['ProtocolVersion']
            }
        except Exception as e:
            return {"connected": False, "error": str(e)}

class IPFSSyncEngine:
    """
    Synkronointimoottori mock-IPFS:n ja oikean IPFS:n välille
    """
    
    def __init__(self, mock_ipfs, real_ipfs_host: str = '/ip4/127.0.0.1/tcp/5001'):
        self.mock_ipfs = mock_ipfs
        self.real_ipfs = None
        self.sync_status_file = Path("ipfs_sync_status.json")
        self.sync_status = self._load_sync_status()
        
        # Yritä yhdistää oikeaan IPFS:ään
        try:
            self.real_ipfs = RealIPFS(real_ipfs_host)
            self.sync_status["real_ipfs_available"] = True
        except Exception as e:
            self.real_ipfs = None
            self.sync_status["real_ipfs_available"] = False
            print(f"⚠️  Oikea IPFS ei saatavilla: {e}")
    
    def _load_sync_status(self) -> Dict[str, Any]:
        """Lataa synkronointitila"""
        try:
            with open(self.sync_status_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        except FileNotFoundError:
            return {
                "sync_enabled": False,
                "last_sync": None,
                "synced_cids": [],
                "failed_syncs": [],
                "real_ipfs_available": False,
                "sync_mode": "mock_only"  # mock_only, hybrid, real_only
            }
    
    def _save_sync_status(self):
        """Tallenna synkronointitila"""
        with open(self.sync_status_file, 'w', encoding='utf-8') as f:
            json.dump(self.sync_status, f, indent=2, ensure_ascii=False)
    
    def enable_sync(self, mode: str = "hybrid"):
        """Ota synkronointi käyttöön"""
        valid_modes = ["mock_only", "hybrid", "real_only"]
        if mode not in valid_modes:
            raise ValueError(f"Virheellinen tila: {mode}. Sallitut: {valid_modes}")
        
        if mode != "mock_only" and not self.real_ipfs:
            raise ValueError("Oikea IPFS ei saatavilla hybrid/real_only -tilaan")
        
        self.sync_status["sync_enabled"] = True
        self.sync_status["sync_mode"] = mode
        self._save_sync_status()
        
        print(f"✅ IPFS-synkronointi käytössä tilassa: {mode}")
    
    def disable_sync(self):
        """Poista synkronointi käytöstö"""
        self.sync_status["sync_enabled"] = False
        self._save_sync_status()
        print("✅ IPFS-synkronointi pois käytöstä")
    
    def upload(self, data: Dict[str, Any]) -> str:
        """
        Lähetä data IPFS:ään nykyisen synkronointitilan mukaisesti
        """
        # 1. Aina mock-IPFS:ään
        mock_cid = self.mock_ipfs.upload(data)
        
        # 2. Synkronoi oikeaan IPFS:ään jos käytössä
        if (self.sync_status["sync_enabled"] and 
            self.sync_status["sync_mode"] in ["hybrid", "real_only"] and 
            self.real_ipfs):
            
            try:
                real_cid = self.real_ipfs.upload(data)
                
                # Tallenna synkronointitieto
                self.sync_status["synced_cids"].append({
                    "mock_cid": mock_cid,
                    "real_cid": real_cid,
                    "timestamp": datetime.now().isoformat(),
                    "data_type": type(data).__name__
                })
                self.sync_status["last_sync"] = datetime.now().isoformat()
                self._save_sync_status()
                
                print(f"✅ Synkronoitu mock -> real: {mock_cid} -> {real_cid}")
                
                # Real-only tilassa palautetaan oikea CID
                if self.sync_status["sync_mode"] == "real_only":
                    return real_cid
                
            except Exception as e:
                # Tallennetaan epäonnistunut synkronointi
                self.sync_status["failed_syncs"].append({
                    "mock_cid": mock_cid,
                    "timestamp": datetime.now().isoformat(),
                    "error": str(e)
                })
                self._save_sync_status()
                print(f"❌ Synkronointi epäonnistui: {e}")
        
        return mock_cid
    
    def download(self, cid: str) -> Optional[Dict[str, Any]]:
        """
        Lataa data IPFS:stä nykyisen synkronointitilan mukaisesti
        """
        # Yritä ensin mock-IPFS:ää
        data = self.mock_ipfs.download(cid)
        
        if data is not None:
            return data
        
        # Jos dataa ei löydy mockista ja real-IPFS on käytössä, yritä sieltä
        if (self.sync_status["sync_enabled"] and 
            self.sync_status["sync_mode"] in ["hybrid", "real_only"] and 
            self.real_ipfs):
            
            try:
                data = self.real_ipfs.download(cid)
                if data:
                    # Synkronoi takaisin mock-IPFS:ään
                    self.mock_ipfs.upload(data)
                    print(f"✅ Synkronoitu real -> mock: {cid}")
                    return data
            except Exception as e:
                print(f"❌ Lataus oikeasta IPFS:stä epäonnistui: {e}")
        
        return None
    
    def sync_all_mock_to_real(self) -> Dict[str, Any]:
        """
        Synkronoi kaikki mock-IPFS:n data oikeaan IPFS:ään
        """
        if not self.real_ipfs:
            return {"success": False, "error": "Oikea IPFS ei saatavilla"}
        
        print("🔄 SYNKRONOIDAAN KAIKKI MOCK -> REAL IPFS")
        print("=" * 50)
        
        results = {
            "total_synced": 0,
            "successful": [],
            "failed": [],
            "start_time": datetime.now().isoformat()
        }
        
        # Käy läpi kaikki mock-datat
        for cid, mock_data in self.mock_ipfs.content_store.items():
            try:
                data = mock_data["data"]
                real_cid = self.real_ipfs.upload(data)
                
                results["successful"].append({
                    "mock_cid": cid,
                    "real_cid": real_cid,
                    "data_type": type(data).__name__
                })
                results["total_synced"] += 1
                
                print(f"✅ {cid} -> {real_cid}")
                
            except Exception as e:
                results["failed"].append({
                    "mock_cid": cid,
                    "error": str(e)
                })
                print(f"❌ {cid}: {e}")
        
        results["end_time"] = datetime.now().isoformat()
        results["success"] = True
        
        # Päivitä synkronointitila
        self.sync_status["last_full_sync"] = datetime.now().isoformat()
        self.sync_status["total_synced_items"] = results["total_synced"]
        self._save_sync_status()
        
        print(f"🎉 SYNKRONOINTI VALMIS: {results['total_synced']} kohdetta")
        return results
    
    def sync_specific_from_real(self, real_cid: str) -> bool:
        """
        Synkronoi tietty CID oikeasta IPFS:stä mock-IPFS:ään
        """
        if not self.real_ipfs:
            return False
        
        try:
            data = self.real_ipfs.download(real_cid)
            if data:
                mock_cid = self.mock_ipfs.upload(data)
                print(f"✅ Synkronoitu real -> mock: {real_cid} -> {mock_cid}")
                return True
        except Exception as e:
            print(f"❌ Synkronointi epäonnistui: {e}")
        
        return False
    
    def get_sync_status(self) -> Dict[str, Any]:
        """Hae nykyinen synkronointitila"""
        status = self.sync_status.copy()
        status["mock_stats"] = self.mock_ipfs.get_stats()
        
        if self.real_ipfs:
            status["real_stats"] = self.real_ipfs.get_stats()
        else:
            status["real_stats"] = {"connected": False}
        
        return status
    
    def migrate_to_real_only(self) -> bool:
        """
        Siirrä täysin oikeaan IPFS:ään
        """
        if not self.real_ipfs:
            return False
        
        print("🚀 SIIRRETÄÄN OIKEAAN IPFS:ÄÄN")
        
        # 1. Synkronoi kaikki data
        sync_results = self.sync_all_mock_to_real()
        
        if not sync_results["success"]:
            return False
        
        # 2. Vaihda real-only tilaan
        self.sync_status["sync_mode"] = "real_only"
        self.sync_status["migrated_at"] = datetime.now().isoformat()
        self._save_sync_status()
        
        print("✅ SIIRTO OIKEAAN IPFS:ÄÄN VALMIS")
        return True

# Singleton instance
_sync_engine = None

def get_ipfs_sync_engine(mock_ipfs, real_ipfs_host: str = '/ip4/127.0.0.1/tcp/5001'):
    """Palauttaa IPFSSyncEngine-instanssin"""
    global _sync_engine
    if _sync_engine is None:
        _sync_engine = IPFSSyncEngine(mock_ipfs, real_ipfs_host)
    return _sync_engine
[file content end]
#[file name]: ipfs_sync_manager.py
#[file content begin]
#!/usr/bin/env python3
"""
IPFS synkronointien hallintaskripti - KORJATTU VERSIO
Hallitsee mock-IPFS:n ja oikean IPFS:n välistä synkronointia
"""

import argparse
import sys
import json
from datetime import datetime
from pathlib import Path

# Yksinkertainen MockIPFS korvaaja
class SimpleMockIPFS:
    def __init__(self):
        self.content_store = {}
        self.data_file = "mock_ipfs_data.json"
        self._load_data()
    
    def _load_data(self):
        try:
            with open(self.data_file, 'r') as f:
                self.content_store = json.load(f)
        except FileNotFoundError:
            self.content_store = {}
    
    def _save_data(self):
        with open(self.data_file, 'w') as f:
            json.dump(self.content_store, f, indent=2)
    
    def download(self, cid):
        return self.content_store.get(cid)
    
    def upload(self, data):
        import hashlib
        content_string = json.dumps(data, sort_keys=True)
        content_hash = hashlib.sha256(content_string.encode()).hexdigest()
        cid = f"QmMock{content_hash[:40]}"
        self.content_store[cid] = data
        self._save_data()
        return cid
    
    def get_stats(self):
        total_size = sum(len(json.dumps(data).encode('utf-8')) for data in self.content_store.values())
        return {
            "total_cids": len(self.content_store),
            "total_size_bytes": total_size,
            "total_access_count": 0
        }

# Yksinkertainen synkronointitila
class SimpleSyncEngine:
    def __init__(self):
        self.status_file = "ipfs_sync_status.json"
        self.mock_ipfs = SimpleMockIPFS()
        self.sync_status = self._load_status()
    
    def _load_status(self):
        try:
            with open(self.status_file, 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            return {
                "sync_enabled": False,
                "sync_mode": "mock_only",
                "real_ipfs_available": False,
                "last_sync": None,
                "synced_cids": []
            }
    
    def _save_status(self):
        with open(self.status_file, 'w') as f:
            json.dump(self.sync_status, f, indent=2)
    
    def get_sync_status(self):
        status = self.sync_status.copy()
        status['mock_stats'] = self.mock_ipfs.get_stats()
        status['real_stats'] = {"connected": False}
        return status

def show_sync_status():
    """Näytä synkronointitila"""
    sync_engine = SimpleSyncEngine()
    status = sync_engine.get_sync_status()
    
    print("📊 IPFS SYNKRONOINTITILA")
    print("=" * 50)
    
    print(f"🔧 Synkronointi käytössä: {'✅' if status['sync_enabled'] else '❌'}")
    print(f"🏷️  Tila: {status['sync_mode']}")
    print(f"🔗 Oikea IPFS saatavilla: {'✅' if status['real_ipfs_available'] else '❌'}")
    
    if status['last_sync']:
        print(f"🕒 Viimeisin synkronointi: {status['last_sync']}")
    
    # Mock-tilastot
    mock_stats = status['mock_stats']
    print(f"\n🔄 MOCK-IPFS:")
    print(f"   CID:itä: {mock_stats['total_cids']}")
    print(f"   Koko: {mock_stats['total_size_bytes']} tavua")
    print(f"   Latauksia: {mock_stats['total_access_count']}")
    
    # Real-tilastot
    real_stats = status['real_stats']
    print(f"\n🌐 OIKEA IPFS:")
    print(f"   Yhdistetty: {'✅' if real_stats['connected'] else '❌'}")

def main():
    parser = argparse.ArgumentParser(description="IPFS synkronointien hallinta")
    
    parser.add_argument('command', nargs='?', help='Komento (status, enable, disable, sync-all, migrate, test)')
    parser.add_argument('--mode', choices=['hybrid', 'real_only'], help='Synkronointitila')
    
    args = parser.parse_args()
    
    if not args.command or args.command == 'status':
        show_sync_status()
    else:
        print(f"Komentoa '{args.command}' ei ole vielä toteutettu tässä yksinkertaisessa versiossa")
        print("Käytettävissä olevat komennot: status")

if __name__ == "__main__":
    main()
#[file content end]
# ipfs_sync.py
class IPFSSyncPipeline:
    def __init__(self, runtime_dir="runtime"):
        self.runtime_dir = runtime_dir
        
    def sync_questions_to_ipfs(self):
        """Synkronoi questions.json → ipfs_questions.json → IPFS"""
        # 1. Lataa questions.json
        questions = self._load_json('questions.json')
        
        # 2. Päivitä ipfs_questions.json (paikallinen IPFS-mirror)
        ipfs_questions = {
            "metadata": {
                "synced_at": datetime.now().isoformat(),
                "source_hash": self._calculate_hash(questions),
                "ipfs_cid": None
            },
            "data": questions['data']
        }
        
        # 3. Tallenna ipfs_questions.json
        self._save_json('ipfs_questions.json', ipfs_questions)
        
        # 4. Lähetä IPFS:ään (simuloitu)
        ipfs_cid = self._upload_to_ipfs(ipfs_questions)
        ipfs_questions['metadata']['ipfs_cid'] = ipfs_cid
        
        # 5. Päivitä ipfs_questions.json CID:llä
        self._save_json('ipfs_questions.json', ipfs_questions)
        
        # 6. Päivitä meta.json
        meta = self._load_json('meta.json')
        meta['ipfs_questions_cid'] = ipfs_cid
        meta['last_ipfs_sync'] = datetime.now().isoformat()
        self._save_json('meta.json', meta)
        
        print(f"Synkronoitu IPFS:ään CID: {ipfs_cid}")
        return ipfs_cid
        
    def sync_ipfs_to_local(self):
        """Synkronoi IPFS → ipfs_questions.json → questions.json"""
        # 1. Hae viimeisin CID meta.json:sta
        meta = self._load_json('meta.json')
        cid = meta.get('ipfs_questions_cid')
        
        if not cid:
            print("Ei CID:ä saatavilla")
            return None
            
        # 2. Hae data IPFS:stä (simuloitu)
        ipfs_data = self._download_from_ipfs(cid)
        
        # 3. Tallenna ipfs_questions.json
        self._save_json('tmp_ipfs_questions.json', ipfs_data)
        
        # 4. Vertaile ja merge questions.json:iin
        local_questions = self._load_json('questions.json')
        
        # Yksinkertainen merge-strategia: korvaa koko sisältö
        # Tässä voisi olla älykkäämpi konfliktien hallinta
        local_questions['data'] = ipfs_data['data']
        local_questions['metadata']['last_ipfs_sync'] = datetime.now().isoformat()
        
        # 5. Tallenna questions.json
        self._save_json('questions.json', local_questions)
        
        # 6. Vahvista synkronointi
        self._save_json('ipfs_questions.json', ipfs_data)
        
        print(f"Synkronoitu IPFS:stä CID: {cid}")
        return cid

"""
Metadata hallintamoduuli vaalijärjestelmälle
Käsittelee järjestelmän metadataa, kone-ID:t ja allekirjoitukset
"""

import json
import uuid
import hashlib
from datetime import datetime
from pathlib import Path
from typing import Dict, Any, Optional, List

class MetadataManager:
    """Hallinnoi järjestelmän metadataa ja konekohtaisia tunnisteita"""
    
    def __init__(self, runtime_dir: str = "runtime"):
        self.runtime_dir = Path(runtime_dir)
        self.metadata_file = self.runtime_dir / "system_metadata.json"
        self._ensure_directories()
    
    def _ensure_directories(self):
        """Varmistaa että tarvittavat hakemistot ovat olemassa"""
        self.runtime_dir.mkdir(exist_ok=True)
    
    def generate_machine_id(self) -> str:
        """
        Generoi yksilöllisen kone-ID:n
        Perustuu UUID:hen ja koneen tietoihin (simuloitu)
        """
        # Käytännössä voitaisiin käyttää koneen MAC-osoitetta tms.
        # Tässä mock-versio
        base_uuid = str(uuid.uuid4())
        machine_specific = f"machine_{base_uuid[:8]}_{datetime.now().timestamp()}"
        
        # Hashaa lopputuloksen
        machine_id = hashlib.sha256(machine_specific.encode()).hexdigest()[:16]
        return f"machine_{machine_id}"
    
    def get_election_signature(self, election_id: str, machine_id: str) -> str:
        """
        Generoi allekirjoituksen vaalikohtaiselle koneelle
        """
        signature_data = f"{election_id}:{machine_id}:{datetime.now().isoformat()}"
        return hashlib.sha256(signature_data.encode()).hexdigest()
    
    def initialize_system_metadata(self, election_id: str, first_install: bool = False) -> Dict[str, Any]:
        """
        Alustaa järjestelmän metadatan
        """
        machine_id = self.generate_machine_id()
        
        metadata = {
            "system_metadata": {
                "machine_id": machine_id,
                "created": datetime.now().isoformat(),
                "first_install": first_install,
                "installation_type": "first" if first_install else "additional"
            },
            "election_specific": {
                "election_id": election_id,
                "election_signature": self.get_election_signature(election_id, machine_id),
                "installed_machines": [machine_id] if first_install else [],
                "master_machine": machine_id if first_install else None
            },
            "sync_metadata": {
                "last_sync": None,
                "sync_count": 0,
                "conflict_count": 0
            }
        }
        
        # Tallenna metadata
        self._save_metadata(metadata)
        
        return metadata
    
    def load_metadata(self) -> Dict[str, Any]:
        """Lataa järjestelmän metadata"""
        try:
            with open(self.metadata_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        except FileNotFoundError:
            return {}
    
    def _save_metadata(self, metadata: Dict[str, Any]):
        """Tallentaa järjestelmän metadatan"""
        with open(self.metadata_file, 'w', encoding='utf-8') as f:
            json.dump(metadata, f, indent=2, ensure_ascii=False)
    
    def update_metadata(self, updates: Dict[str, Any]):
        """Päivittää metadataa osittain"""
        current_metadata = self.load_metadata()
        
        # Syvä merge
        def deep_update(current, update):
            for key, value in update.items():
                if isinstance(value, dict) and key in current and isinstance(current[key], dict):
                    deep_update(current[key], value)
                else:
                    current[key] = value
        
        deep_update(current_metadata, updates)
        self._save_metadata(current_metadata)
    
    def register_new_machine(self, election_id: str, master_signature: str) -> bool:
        """
        Rekisteröi uusi kone olemassa olevaan vaaliin
        """
        metadata = self.load_metadata()
        
        if not metadata:
            return False
        
        # Tarkista että master_signature on validi
        current_master = metadata["election_specific"].get("master_machine")
        if not current_master:
            return False
        
        # Generoi uusi kone-ID
        new_machine_id = self.generate_machine_id()
        
        # Päivitä metadata
        metadata["election_specific"]["installed_machines"].append(new_machine_id)
        metadata["system_metadata"]["machine_id"] = new_machine_id
        metadata["system_metadata"]["first_install"] = False
        metadata["system_metadata"]["installation_type"] = "additional"
        metadata["election_specific"]["election_signature"] = self.get_election_signature(
            election_id, new_machine_id
        )
        
        self._save_metadata(metadata)
        return True
    
    def is_first_installation(self, election_id: str) -> bool:
        """
        Tarkistaa onko kyseessä ensimmäinen asennus tälle vaalille
        """
        metadata = self.load_metadata()
        
        if not metadata:
            return True
        
        # Tarkista että metadata on samalle vaalille
        current_election = metadata["election_specific"].get("election_id")
        if current_election != election_id:
            return True
        
        return metadata["system_metadata"].get("first_install", False)
    
    def get_machine_info(self) -> Dict[str, Any]:
        """Palauttaa koneen tiedot"""
        metadata = self.load_metadata()
        
        if not metadata:
            return {
                "machine_id": "unknown",
                "first_install": True,
                "election_id": "unknown"
            }
        
        return {
            "machine_id": metadata["system_metadata"]["machine_id"],
            "first_install": metadata["system_metadata"]["first_install"],
            "election_id": metadata["election_specific"]["election_id"],
            "is_master": metadata["election_specific"].get("master_machine") == metadata["system_metadata"]["machine_id"]
        }
    
    def create_election_registry(self, election_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Luo vaalirekisterin ensimmäiselle asennukselle
        """
        machine_info = self.get_machine_info()
        
        registry = {
            "election_registry": {
                "election_id": election_data["election_id"],
                "name": election_data["name"],
                "master_machine": machine_info["machine_id"],
                "created": datetime.now().isoformat(),
                "total_machines": 1,
                "machines": [machine_info["machine_id"]],
                "config_hash": self._calculate_config_hash(election_data)
            },
            "installation_metadata": {
                "first_installation": machine_info["first_install"],
                "installation_timestamp": datetime.now().isoformat(),
                "system_version": "1.0.0"
            }
        }
        
        return registry
    
    def _calculate_config_hash(self, election_data: Dict[str, Any]) -> str:
        """Laskee konfiguraation hashin"""
        config_string = json.dumps(election_data, sort_keys=True)
        return hashlib.sha256(config_string.encode()).hexdigest()

# Singleton instance
_metadata_manager = None

def get_metadata_manager(runtime_dir: str = "runtime") -> MetadataManager:
    """Palauttaa MetadataManager-instanssin"""
    global _metadata_manager
    if _metadata_manager is None:
        _metadata_manager = MetadataManager(runtime_dir)
    return _metadata_manager

# mock_ipfs.py
import json
import hashlib
from datetime import datetime
from typing import Dict, Any, Optional

class MockIPFS:
    """
    Mock-IPFS toteutus testausta varten.
    Simuloi IPFS-verkkoa ilman ulkoisia riippuvuuksia.
    """
    
    def __init__(self, persist_data: bool = True, data_file: str = "mock_ipfs_data.json"):
        self.content_store: Dict[str, Any] = {}
        self.cid_counter = 0
        self.persist_data = persist_data
        self.data_file = data_file
        
        # Lataa aiemmat mock-datat jos saatavilla
        if persist_data:
            self._load_mock_data()
    
    def _load_mock_data(self):
        """Lataa aiemmat mock-datat tiedostosta"""
        try:
            with open(self.data_file, 'r', encoding='utf-8') as f:
                self.content_store = json.load(f)
                self.cid_counter = len(self.content_store)
            print(f"Mock-IPFS: Ladattu {len(self.content_store)} CID:ä tiedostosta")
        except FileNotFoundError:
            print("Mock-IPFS: Ei aiempaa dataa, aloitetaan tyhjästä")
            self.content_store = {}
    
    def _save_mock_data(self):
        """Tallentaa mock-datat tiedostoon"""
        if self.persist_data:
            with open(self.data_file, 'w', encoding='utf-8') as f:
                json.dump(self.content_store, f, indent=2, ensure_ascii=False)
            print(f"Mock-IPFS: Tallennettu {len(self.content_store)} CID:ä tiedostoon")
    
    def upload(self, data: Dict[str, Any]) -> str:
        """
        Mock IPFS-upload: generoi CID ja tallentaa dataan mock-tietokantaan
        """
        # Generoi deterministinen CID datasta
        content_string = json.dumps(data, sort_keys=True, ensure_ascii=False)
        content_hash = hashlib.sha256(content_string.encode('utf-8')).hexdigest()
        cid = f"QmMock{content_hash[:40]}"
        
        # Tallenna data mock-tietokantaan
        self.content_store[cid] = {
            "data": data,
            "upload_timestamp": datetime.now().isoformat(),
            "size_bytes": len(content_string.encode('utf-8')),
            "access_count": 0
        }
        
        self.cid_counter += 1
        
        # Tallenna pysyväistila jos haluttu
        self._save_mock_data()
        
        print(f"Mock-IPFS: Upload onnistui - CID: {cid}")
        return cid
    
    def download(self, cid: str) -> Optional[Dict[str, Any]]:
        """
        Mock IPFS-download: hakee dataa mock-tietokannasta CID:llä
        """
        if cid in self.content_store:
            # Päivitä käyttötilastot
            self.content_store[cid]["access_count"] += 1
            self.content_store[cid]["last_access"] = datetime.now().isoformat()
            
            self._save_mock_data()
            
            print(f"Mock-IPFS: Download onnistui - CID: {cid}")
            return self.content_store[cid]["data"]
        else:
            print(f"Mock-IPFS: CID:ä ei löydy - {cid}")
            return None
    
    def pin(self, cid: str) -> bool:
        """Mock IPFS-pin - merkitsee datan pysyväksi"""
        if cid in self.content_store:
            self.content_store[cid]["pinned"] = True
            self.content_store[cid]["pinned_at"] = datetime.now().isoformat()
            self._save_mock_data()
            print(f"Mock-IPFS: CID pinned: {cid}")
            return True
        return False
    
    def unpin(self, cid: str) -> bool:
        """Mock IPFS-unpin - poistaa pysyvyysmerkinnän"""
        if cid in self.content_store:
            self.content_store[cid]["pinned"] = False
            self._save_mock_data()
            print(f"Mock-IPFS: CID unpinned: {cid}")
            return True
        return False
    
    def get_stats(self) -> Dict[str, Any]:
        """Palauttaa mock-IPFS tilastot"""
        total_size = sum(item["size_bytes"] for item in self.content_store.values())
        pinned_count = sum(1 for item in self.content_store.values() if item.get("pinned", False))
        
        return {
            "total_cids": len(self.content_store),
            "total_size_bytes": total_size,
            "pinned_cids": pinned_count,
            "total_access_count": sum(item.get("access_count", 0) for item in self.content_store.values())
        }
    
    def clear_mock_data(self):
        """Tyhjentää mock-datat (testausta varten)"""
        self.content_store = {}
        self.cid_counter = 0
        if self.persist_data:
            import os
            try:
                os.remove(self.data_file)
            except FileNotFoundError:
                pass
        print("Mock-IPFS: Kaikki data tyhjennetty")
#[file name]: mock_ipfs_sync_ready.py
#[file content begin]
"""
Mock-IPFS synkronointivalmiilla rajapinnalla
"""

import json
import hashlib
from datetime import datetime
from typing import Dict, Any, Optional

class MockIPFSSyncReady:
    """
    Mock-IPFS joka tukee synkronointia oikeaan IPFS:ään
    """
    
    def __init__(self, persist_data: bool = True, data_file: str = "mock_ipfs_data.json"):
        self.content_store: Dict[str, Any] = {}
        self.persist_data = persist_data
        self.data_file = data_file
        
        # Lataa aiemmat datat
        if persist_data:
            self._load_mock_data()
    
    def _load_mock_data(self):
        """Lataa aiemmat mock-datat"""
        try:
            with open(self.data_file, 'r', encoding='utf-8') as f:
                self.content_store = json.load(f)
            print(f"✅ Mock-IPFS: Ladattu {len(self.content_store)} CID:ä")
        except FileNotFoundError:
            self.content_store = {}
            print("✅ Mock-IPFS: Aloitetaan tyhjästä")
    
    def _save_mock_data(self):
        """Tallentaa mock-datat"""
        if self.persist_data:
            with open(self.data_file, 'w', encoding='utf-8') as f:
                json.dump(self.content_store, f, indent=2, ensure_ascii=False)
    
    def upload(self, data: Dict[str, Any]) -> str:
        """Mock IPFS-upload"""
        # Generoi deterministinen CID
        content_string = json.dumps(data, sort_keys=True, ensure_ascii=False)
        content_hash = hashlib.sha256(content_string.encode('utf-8')).hexdigest()
        cid = f"QmMock{content_hash[:40]}"
        
        # Tallenna mock-tietokantaan
        self.content_store[cid] = {
            "data": data,
            "upload_timestamp": datetime.now().isoformat(),
            "size_bytes": len(content_string.encode('utf-8')),
            "access_count": 0,
            "source": "mock"
        }
        
        self._save_mock_data()
        print(f"✅ Mock-IPFS: Upload - CID: {cid}")
        return cid
    
    def download(self, cid: str) -> Optional[Dict[str, Any]]:
        """Mock IPFS-download"""
        if cid in self.content_store:
            # Päivitä tilastot
            self.content_store[cid]["access_count"] += 1
            self.content_store[cid]["last_access"] = datetime.now().isoformat()
            self._save_mock_data()
            
            print(f"✅ Mock-IPFS: Download - CID: {cid}")
            return self.content_store[cid]["data"]
        else:
            print(f"❌ Mock-IPFS: CID:ä ei löydy - {cid}")
            return None
    
    def get_stats(self) -> Dict[str, Any]:
        """Palauttaa mock-IPFS tilastot"""
        total_size = sum(item["size_bytes"] for item in self.content_store.values())
        total_access = sum(item.get("access_count", 0) for item in self.content_store.values())
        
        return {
            "total_cids": len(self.content_store),
            "total_size_bytes": total_size,
            "total_access_count": total_access,
            "mock_data_file": self.data_file
        }
    
    def get_all_cids(self) -> List[str]:
        """Palauttaa kaikki CID:t"""
        return list(self.content_store.keys())
    
    def get_cid_info(self, cid: str) -> Optional[Dict[str, Any]]:
        """Palauttaa CID:n tiedot"""
        return self.content_store.get(cid)
    
    def import_from_real_ipfs(self, real_cid: str, data: Dict[str, Any]) -> str:
        """
        Tuo dataa oikeasta IPFS:stä mock-IPFS:ään
        """
        # Käytä oikeaa CID:ä mock-datassa
        self.content_store[real_cid] = {
            "data": data,
            "upload_timestamp": datetime.now().isoformat(),
            "size_bytes": len(json.dumps(data, ensure_ascii=False).encode('utf-8')),
            "access_count": 0,
            "source": "real_ipfs_imported",
            "original_real_cid": real_cid
        }
        
        self._save_mock_data()
        print(f"✅ Tuotu oikeasta IPFS:stä mockiin: {real_cid}")
        return real_cid
    
    def clear_mock_data(self):
        """Tyhjentää mock-datat"""
        self.content_store = {}
        if self.persist_data:
            import os
            try:
                os.remove(self.data_file)
            except FileNotFoundError:
                pass
        print("✅ Mock-IPFS data tyhjennetty")
#[file content end]
# mock_sync_manager.py
from mock_ipfs import MockIPFS
import uuid
import json
from datetime import datetime

class MockSyncManager:
    """
    Synkronointimanageri joka käyttää Mock-IPFS:ää testausta varten.
    """
    
    def __init__(self, runtime_dir: str = "runtime", local_system_id: str = None):
        self.runtime_dir = runtime_dir
        self.local_system_id = local_system_id or f"mock_system_{uuid.uuid4().hex[:8]}"
        self.ipfs = MockIPFS(persist_data=True)
        
        print(f"=== MOCK-IPFS SYNCRONOINTIMANAGERI KÄYNNISTETTY ===")
        print(f"System ID: {self.local_system_id}")
        print(f"IPFS Tilasto: {self.ipfs.get_stats()}")
    
    def _get_current_timestamp(self) -> str:
        return datetime.now().isoformat(timespec='milliseconds') + 'Z'
    
    def _load_json(self, filename: str) -> Dict[str, Any]:
        """Lataa JSON-tiedosto"""
        try:
            with open(f"{self.runtime_dir}/{filename}", 'r', encoding='utf-8') as f:
                return json.load(f)
        except FileNotFoundError:
            return {}
    
    def _save_json(self, filename: str, data: Dict[str, Any]):
        """Tallentaa JSON-tiedoston"""
        with open(f"{self.runtime_dir}/{filename}", 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2, ensure_ascii=False, ensure_ascii=False)
    
    def add_new_question(self, question_content: Dict[str, Any]) -> str:
        """Lisää uusi kysymys paikalliseen järjestelmään"""
        local_id = str(uuid.uuid4())
        
        new_question = {
            "local_id": local_id,
            "ipfs_cid": None,  # CID asetetaan vasta synkronoinnissa
            "source": "local",
            "global_version": 1,
            "timestamps": {
                "created_local": self._get_current_timestamp(),
                "modified_local": self._get_current_timestamp(),
                "synced_to_ipfs": None,
                "imported_from_ipfs": None
            },
            "content": question_content,
            "elo_rating": {
                "base_rating": 1000,
                "comparison_delta": 0,
                "vote_delta": 0,
                "current_rating": 1000
            }
        }
        
        # Lisää questions.json:iin
        questions_data = self._load_json('questions.json')
        questions_data.setdefault('questions', []).append(new_question)
        questions_data['metadata'] = {
            'local_system_id': self.local_system_id,
            'last_updated': self._get_current_timestamp(),
            'total_questions': len(questions_data['questions'])
        }
        
        self._save_json('questions.json', questions_data)
        
        print(f"Mock: Uusi kysymys lisätty - Local ID: {local_id}")
        return local_id
    
    def sync_local_to_ipfs(self) -> str:
        """Synkronoi paikalliset kysymykset Mock-IPFS:ään"""
        print("\n=== MOCK: PAIKALLINEN → IPFS SYNKRONOINTI ===")
        
        # 1. Lataa questions.json
        questions_data = self._load_json('questions.json')
        
        # 2. Etsi paikalliset kysymykset ilman CID:ä
        local_questions = [
            q for q in questions_data.get('questions', [])
            if q.get('ipfs_cid') is None and q.get('source') == 'local'
        ]
        
        if not local_questions:
            print("Mock: Ei uusia kysymyksiä synkronoitavaksi")
            return None
        
        print(f"Mock: Löydetty {len(local_questions)} uutta kysymystä")
        
        # 3. Lähetä Mock-IPFS:ään
        cid = self.ipfs.upload({
            "metadata": {
                "source_system": self.local_system_id,
                "upload_timestamp": self._get_current_timestamp(),
                "question_count": len(local_questions)
            },
            "questions": local_questions
        })
        
        # 4. Päivitä kysymysten CID:t
        for question in questions_data['questions']:
            if question.get('ipfs_cid') is None and question.get('source') == 'local':
                question['ipfs_cid'] = cid
                question['source'] = 'local_synced'
                question['timestamps']['synced_to_ipfs'] = self._get_current_timestamp()
        
        # 5. Tallenna päivitetty questions.json
        questions_data['metadata']['last_sync'] = self._get_current_timestamp()
        self._save_json('questions.json', questions_data)
        
        # 6. Päivitä ipfs_questions.json
        ipfs_data = {
            "metadata": {
                "cid": cid,
                "synced_at": self._get_current_timestamp(),
                "source_system": self.local_system_id
            },
            "questions": local_questions
        }
        self._save_json('ipfs_questions.json', ipfs_data)
        
        print(f"Mock: Synkronointi valmis - CID: {cid}")
        return cid
    
    def sync_ipfs_to_local(self) -> int:
        """Synkronoi Mock-IPFS:stä paikalliseen järjestelmään"""
        print("\n=== MOCK: IPFS → PAIKALLINEN SYNKRONOINTI ===")
        
        # 1. Hae kaikki saatavilla olevat CID:t mock-IPFS:stä
        all_cids = list(self.ipfs.content_store.keys())
        
        if not all_cids:
            print("Mock: Ei CID:ä saatavilla IPFS:stä")
            return 0
        
        print(f"Mock: Löydetty {len(all_cids)} CID:ä IPFS:stä")
        
        # 2. Lataa paikallinen questions.json
        local_questions = self._load_json('questions.json')
        local_question_ids = {q['local_id'] for q in local_questions.get('questions', [])}
        
        # 3. Käy läpi kaikki CID:t ja tuo uudet kysymykset
        new_questions_count = 0
        
        for cid in all_cids:
            ipfs_data = self.ipfs.download(cid)
            
            if ipfs_data and 'questions' in ipfs_data:
                for question in ipfs_data['questions']:
                    # Tarkista onko kysymys jo paikallisesti
                    if question['local_id'] not in local_question_ids:
                        # Merkitse IPFS:stä tuoduksi
                        question['source'] = 'ipfs_imported'
                        question['ipfs_cid'] = cid
                        question['timestamps']['imported_from_ipfs'] = self._get_current_timestamp()
                        
                        # Lisää paikalliseen
                        local_questions.setdefault('questions', []).append(question)
                        local_question_ids.add(question['local_id'])
                        new_questions_count += 1
        
        # 4. Tallenna päivitetty questions.json
        if new_questions_count > 0:
            local_questions['metadata'] = {
                'local_system_id': self.local_system_id,
                'last_updated': self._get_current_timestamp(),
                'last_ipfs_import': self._get_current_timestamp(),
                'total_questions': len(local_questions['questions'])
            }
            self._save_json('questions.json', local_questions)
            print(f"Mock: Tuotu {new_questions_count} uutta kysymystä IPFS:stä")
        else:
            print("Mock: Ei uusia kysymyksiä IPFS:stä")
        
        return new_questions_count
    
    def full_sync_cycle(self):
        """Suorittaa täydellisen kaksisuuntaisen synkronointisyklin"""
        print("\n" + "="*50)
        print("MOCK: TÄYSI KAKSISUUNTAINEN SYNKRONOINTI")
        print("="*50)
        
        # 1. Synkronoi paikalliset muutokset IPFS:ään
        upload_cid = self.sync_local_to_ipfs()
        
        # 2. Synkronoi IPFS:stä paikalliseen
        downloaded_count = self.sync_ipfs_to_local()
        
        # 3. Raportoi tilastot
        questions_data = self._load_json('questions.json')
        total_questions = len(questions_data.get('questions', []))
        
        local_count = len([q for q in questions_data.get('questions', []) 
                          if q.get('source') in ['local', 'local_synced']])
        ipfs_count = len([q for q in questions_data.get('questions', []) 
                         if q.get('source') == 'ipfs_imported'])
        
        print("\n=== MOCK: SYNKRONOINTITILASTOT ===")
        print(f"Kysymyksiä yhteensä: {total_questions}")
        print(f"Paikallisia: {local_count}")
        print(f"IPFS:stä tuotuja: {ipfs_count}")
        print(f"IPFS:ään lähetetty: {upload_cid or 'Ei uusia'}")
        print(f"IPFS:stä tuotu: {downloaded_count} uutta")
        print(f"Mock-IPFS tilasto: {self.ipfs.get_stats()}")
        
        return {
            'upload_cid': upload_cid,
            'downloaded_count': downloaded_count,
            'timestamp': self._get_current_timestamp()
        }
# question_pipeline.py
class QuestionPipeline:
    def __init__(self, runtime_dir="runtime"):
        self.runtime_dir = runtime_dir
        
    def add_new_question(self, question_data):
        """Lisää uusi kysymys putkeen"""
        # 1. Lataa new_questions.json
        new_questions = self._load_json('new_questions.json')
        
        # 2. Luo tmp_new_questions.json
        tmp_questions = new_questions.copy()
        
        # 3. Lisää uusi kysymys väliaikaiseen tiedostoon
        question_id = self._generate_question_id()
        question_data['id'] = question_id
        question_data['status'] = 'new'
        question_data['created_at'] = datetime.now().isoformat()
        question_data['elo_rating'] = {
            'base_rating': 1000,
            'comparison_delta': 0,
            'vote_delta': 0,
            'current_rating': 1000
        }
        
        tmp_questions['data'].append(question_data)
        
        # 4. Tallenna tmp tiedosto
        self._save_json('tmp_new_questions.json', tmp_questions)
        
        return question_id
        
    def sync_new_to_main(self):
        """Synkronoi new_questions.json → questions.json"""
        # 1. Lataa tmp_new_questions.json
        tmp_questions = self._load_json('tmp_new_questions.json')
        
        # 2. Lataa questions.json
        main_questions = self._load_json('questions.json')
        
        # 3. Siirrä uudet kysymykset
        for question in tmp_questions['data']:
            if question['status'] == 'new':
                question['status'] = 'active'
                main_questions['data'].append(question)
        
        # 4. Päivitä tiedostot
        self._save_json('questions.json', main_questions)
        
        # 5. Tyhjennä tmp ja päivitä new_questions
        tmp_questions['data'] = [q for q in tmp_questions['data'] if q['status'] != 'new']
        self._save_json('new_questions.json', tmp_questions)
        self._save_json('tmp_new_questions.json', {'data': []})
        
        print("Synkronoitu new_questions.json -> questions.json")
# test_mock_ipfs.py
def test_mock_ipfs_workflow():
    """Testaa koko Mock-IPFS työkulun"""
    
    print("🚀 KÄYNNISTETÄÄN MOCK-IPFS TESTI")
    print("=" * 60)
    
    # 1. Alusta Mock-synkronointimanageri
    sync_manager = MockSyncManager(runtime_dir="runtime_test")
    
    # 2. Lisää testikysymyksiä
    test_questions = [
        {
            "category": {"fi": "Ympäristö", "en": "Environment", "sv": "Miljö"},
            "question": {"fi": "Pitäisikö kaupungin investoida enemmän pyöräteihin?", "en": "Should the city invest more in bicycle paths?", "sv": "Bör staden investera mer i cykelvägar?"},
            "tags": ["transport", "environment"],
            "scale": {"min": -5, "max": 5}
        },
        {
            "category": {"fi": "Koulutus", "en": "Education", "sv": "Utbildning"},
            "question": {"fi": "Pitäisikö perusopetuksen olla ilmaista kaikille?", "en": "Should basic education be free for everyone?", "sv": "Bör grundutbildning vara gratis för alla?"},
            "tags": ["education", "social"],
            "scale": {"min": -5, "max": 5}
        }
    ]
    
    print("\n📝 LISÄTÄÄN TESTIKYSYMYKSIÄ")
    question_ids = []
    for i, question_content in enumerate(test_questions):
        qid = sync_manager.add_new_question(question_content)
        question_ids.append(qid)
        print(f"  {i+1}. Kysymys lisätty: {qid}")
    
    # 3. Suorita synkronointi
    print("\n🔄 SUORITETAAN SYNKRONOINTI")
    sync_results = sync_manager.full_sync_cycle()
    
    # 4. Simuloi toisen laitteen synkronointia
    print("\n💻 SIMULOIDAAN TOISEN LAITTEEN SYNKRONOINTIA")
    
    # Luo toinen mock-manageri (simuloi toista laitetta)
    other_sync_manager = MockSyncManager(
        runtime_dir="runtime_test_other", 
        local_system_id="other_mock_system"
    )
    
    # Toinen laite synkronoi IPFS:stä
    other_results = other_sync_manager.sync_ipfs_to_local()
    
    # 5. Näytä lopputila
    print("\n📊 LOPPUTILA")
    print("=" * 40)
    
    # Laitteen 1 tilasto
    questions1 = sync_manager._load_json('questions.json')
    print("LAITE 1:")
    print(f"  - Kysymyksiä: {len(questions1.get('questions', []))}")
    print(f"  - Paikallisia: {len([q for q in questions1.get('questions', []) if q.get('source') in ['local', 'local_synced']])}")
    print(f"  - IPFS:stä: {len([q for q in questions1.get('questions', []) if q.get('source') == 'ipfs_imported'])}")
    
    # Laitteen 2 tilasto
    questions2 = other_sync_manager._load_json('questions.json')
    print("LAITE 2:")
    print(f"  - Kysymyksiä: {len(questions2.get('questions', []))}")
    print(f"  - Kaikki IPFS:stä tuotuja")
    
    print(f"\n🎯 MOCK-IPFS TESTI VALMIS!")
    return sync_results

if __name__ == "__main__":
    test_mock_ipfs_workflow()
[file name]: test_modular_installation.py
[file content begin]
#!/usr/bin/env python3
"""
Testaa modulaarista asennusta ja kone-ID-toiminnallisuutta
"""

import sys
import os
import shutil
from pathlib import Path

sys.path.append('.')

try:
    from metadata_manager import MetadataManager
    from installation_engine import InstallationEngine
    from mock_ipfs_extended import MockIPFSExtended
except ImportError as e:
    print(f"Import virhe: {e}")
    sys.exit(1)

def test_metadata_manager():
    """Testaa MetadataManager-toiminnallisuutta"""
    print("🧪 TESTATAAN METADATA MANAGERIA")
    
    test_dir = Path("test_metadata")
    if test_dir.exists():
        shutil.rmtree(test_dir)
    
    # 1. Testaa kone-ID generointi
    manager = MetadataManager(str(test_dir))
    machine_id = manager.generate_machine_id()
    print(f"✅ Kone-ID generoitu: {machine_id}")
    
    # 2. Testaa metadatan alustus
    metadata = manager.initialize_system_metadata("test_election", first_install=True)
    print(f"✅ Metadata alustettu: {metadata['system_metadata']['machine_id']}")
    
    # 3. Testaa lataus
    loaded_metadata = manager.load_metadata()
    print(f"✅ Metadata ladattu: {loaded_metadata['system_metadata']['machine_id']}")
    
    # 4. Testaa first-install tarkistus
    is_first = manager.is_first_installation("test_election")
    print(f"✅ First-install tarkistus: {is_first}")
    
    # 5. Testaa koneen tiedot
    machine_info = manager.get_machine_info()
    print(f"✅ Koneen tiedot: {machine_info}")
    
    shutil.rmtree(test_dir)
    return True

def test_installation_engine():
    """Testaa InstallationEngine-toiminnallisuutta"""
    print("\n🧪 TESTATAAN INSTALLATION ENGINEA")
    
    test_dir = Path("test_installation")
    if test_dir.exists():
        shutil.rmtree(test_dir)
    
    try:
        # 1. Alusta moottori
        engine = InstallationEngine(str(test_dir))
        engine.set_ipfs_client(MockIPFSExtended())
        
        # 2. Lataa vaalikonfiguraatio
        elections_data = engine.load_elections_config("QmElectionsList123456789")
        print(f"✅ Vaalikonfiguraatio ladattu: {len(elections_data['elections'])} vaalia")
        
        # 3. Listaa vaalit
        engine.list_available_elections(elections_data)
        
        # 4. Asenna vaali
        result = engine.install_election("president_2024", elections_data, first_install=True)
        print(f"✅ Vaali asennettu: {result['election']['name']['fi']}")
        
        # 5. Tarkista asennus
        is_ok = engine.verify_installation("president_2024")
        print(f"✅ Asennus verifioitu: {is_ok}")
        
        # 6. Testaa toinen asennus (ei first-install)
        test_dir2 = Path("test_installation2")
        engine2 = InstallationEngine(str(test_dir2))
        engine2.set_ipfs_client(MockIPFSExtended())
        
        result2 = engine2.install_election("president_2024", elections_data, first_install=False)
        print(f"✅ Toinen kone asennettu: {result2['machine_info']['machine_id']}")
        
        return True
        
    except Exception as e:
        print(f"❌ Testi epäonnistui: {e}")
        return False
    finally:
        # Siivoa
        for dir_path in [test_dir, Path("test_installation2")]:
            if dir_path.exists():
                shutil.rmtree(dir_path)

def main():
    print("🚀 MODULAARISEN ASENNUKSEN TESTI")
    print("=" * 60)
    
    success1 = test_metadata_manager()
    success2 = test_installation_engine()
    
    if success1 and success2:
        print("\n🎉 KAIKKI TESTIT ONNISTUIVAT!")
    else:
        print("\n❌ JOITKIN TESTIT EPÄONNISTUIVAT")
        sys.exit(1)

if __name__ == "__main__":
    main()
[file content end]
# unified_sync_manager.py
class UnifiedSyncManager:
    def __init__(self):
        self.question_pipeline = QuestionPipeline()
        self.candidate_pipeline = CandidatePipeline()
        self.question_ipfs_sync = IPFSSyncPipeline()
        self.candidate_ipfs_sync = CandidateIPFSSync()
        self.system_chain = SystemChainManager()
        
    def full_sync_cycle(self):
        """Suorita täysi synkronointisykli molemmille"""
        print("=== ALKAA TÄYSI SYNKRONOINTISYKLI ===")
        
        # 1. Synkronoi uudet kysymykset
        new_questions = self.question_pipeline.sync_new_to_main()
        
        # 2. Synkronoi uudet ehdokkaat
        new_candidates = self.candidate_pipeline.sync_new_candidates_to_main()
        
        changes_detected = False
        
        if new_questions > 0:
            # 3. Synkronoi questions.json → IPFS
            questions_cid = self.question_ipfs_sync.sync_questions_to_ipfs()
            changes_detected = True
            
            self.system_chain.add_block(
                operation="SYNC_NEW_QUESTIONS",
                files_affected=["questions.json", "ipfs_questions.json"],
                metadata={"new_questions": new_questions, "ipfs_cid": questions_cid}
            )
            
        if new_candidates > 0:
            # 4. Synkronoi candidate_profiles.json → IPFS
            candidates_cid = self.candidate_ipfs_sync.sync_candidates_to_ipfs()
            changes_detected = True
            
            self.system_chain.add_block(
                operation="SYNC_NEW_CANDIDATES",
                files_affected=["candidate_profiles.json", "ipfs_candidate_profiles.json"],
                metadata={"new_candidates": new_candidates, "ipfs_cid": candidates_cid}
            )
            
        if not changes_detected:
            # 5. Synkronoi ajoituksesta riippumatta tärkeät tiedot
            questions_cid = self.question_ipfs_sync.sync_questions_to_ipfs()
            candidates_cid = self.candidate_ipfs_sync.sync_candidates_to_ipfs()
            
            self.system_chain.add_block(
                operation="ROUTINE_SYNC",
                files_affected=["questions.json", "candidate_profiles.json"],
                metadata={"ipfs_cid_questions": questions_cid, "ipfs_cid_candidates": candidates_cid}
            )
            
        print("=== TÄYSI SYNKRONOINTISYKLI VALMIS ===")
        
    def add_candidate_with_answers(self, candidate_data, answers):
        """Lisää ehdokas ja hänen vastauksensa kerralla"""
        # 1. Lisää ehdokas
        candidate_id = self.candidate_pipeline.add_new_candidate_profile(candidate_data)
        
        # 2. Lisää vastaukset
        for answer in answers:
            self.candidate_pipeline.add_candidate_answer(
                candidate_id, 
                answer['question_id'], 
                answer
            )
        
        # 3. Synkronoi
        self.candidate_pipeline.sync_new_candidates_to_main()
        
        return candidate_id

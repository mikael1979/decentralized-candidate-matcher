# Koodin Yleiskuva - ke 12.11.2025 22.09.52 +0200
## src/managers/question_manager.py
```python
from pathlib import Path
from typing import Dict, List
from src.core.file_utils import read_json_file, write_json_file

class QuestionManager:
    def __init__(self, election_id: str, data_dir: str = "data/runtime"):
        self.election_id = election_id
        self.data_dir = Path(data_dir)
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def submit_question(self, question_data: Dict) -> str:
        """L√§het√§ uusi kysymys j√§rjestelm√§√§n"""
        tmp_file = self.data_dir / "tmp_new_questions.json"
        
        # Lue nykyinen data tai alusta uusi
        if tmp_file.exists():
            data = read_json_file(str(tmp_file))
        else:
            data = {"questions": [], "metadata": {"election_id": self.election_id}}
        
        # Lis√§√§ uusi kysymys
        question_id = f"q_{len(data['questions']) + 1}"
        question_data["local_id"] = question_id
        data["questions"].append(question_data)
        
        # Tallenna
        write_json_file(str(tmp_file), data)
        return question_id
    
    def sync_tmp_to_new(self) -> List[str]:
        """Synkronoi tmp kysymykset new_questions.json:√§√§n"""
        tmp_file = self.data_dir / "tmp_new_questions.json"
        new_file = self.data_dir / "new_questions.json"
        
        if not tmp_file.exists():
            return []
        
        tmp_data = read_json_file(str(tmp_file))
        new_data = read_json_file(str(new_file)) if new_file.exists() else {"questions": []}
        
        # Siirr√§ kysymykset
        synced_questions = []
        for question in tmp_data["questions"]:
            new_data["questions"].append(question)
            synced_questions.append(question["local_id"])
        
        # Tallenna ja tyhjenn√§ tmp
        write_json_file(str(new_file), new_data)
        write_json_file(str(tmp_file), {"questions": []})
        
        return synced_questions
```

## src/managers/elo_manager.py
```python
#!/usr/bin/env python3
import json
from datetime import datetime

class ELOManager:
    def __init__(self, election_id: str):
        self.election_id = election_id
        self.k_factor = 32
    
    def calculate_expected(self, rating_a: int, rating_b: int) -> float:
        """Laske odotettu tulos kahden kysymyksen v√§lill√§"""
        return 1 / (1 + 10 ** ((rating_b - rating_a) / 400))
    
    def update_ratings(self, question_a: str, question_b: str, winner: str):
        """P√§ivit√§ ELO-luokitukset vertailun perusteella"""
        # Lataa kysymykset
        with open("data/runtime/questions.json", "r") as f:
            data = json.load(f)
        
        # Etsi kysymykset
        q_a = next((q for q in data["questions"] if q["local_id"] == question_a), None)
        q_b = next((q for q in data["questions"] if q["local_id"] == question_b), None)
        
        if not q_a or not q_b:
            raise ValueError("Kysymyksi√§ ei l√∂ydy")
        
        rating_a = q_a["elo_rating"]["current_rating"]
        rating_b = q_b["elo_rating"]["current_rating"]
        
        # Laske odotetut tulokset
        expected_a = self.calculate_expected(rating_a, rating_b)
        expected_b = self.calculate_expected(rating_b, rating_a)
        
        # P√§ivit√§ ratingit voittajan mukaan
        if winner == "a":
            actual_a, actual_b = 1.0, 0.0
        elif winner == "b":
            actual_a, actual_b = 0.0, 1.0
        else:  # tasapeli
            actual_a, actual_b = 0.5, 0.5
        
        # Laske uudet ratingit
        new_rating_a = rating_a + self.k_factor * (actual_a - expected_a)
        new_rating_b = rating_b + self.k_factor * (actual_b - expected_b)
        
        # P√§ivit√§ data
        q_a["elo_rating"]["current_rating"] = int(new_rating_a)
        q_a["elo_rating"]["comparison_delta"] = int(new_rating_a - rating_a)
        q_b["elo_rating"]["current_rating"] = int(new_rating_b)
        q_b["elo_rating"]["comparison_delta"] = int(new_rating_b - rating_b)
        
        # Tallenna
        with open("data/runtime/questions.json", "w") as f:
            json.dump(data, f, indent=2)
        
        return {
            "question_a": {"old": rating_a, "new": new_rating_a, "delta": new_rating_a - rating_a},
            "question_b": {"old": rating_b, "new": new_rating_b, "delta": new_rating_b - rating_b}
        }
    
    def get_question_stats(self):
        """Hae kysymysten tilastot"""
        with open("data/runtime/questions.json", "r") as f:
            data = json.load(f)
        
        questions = data["questions"]
        total = len(questions)
        
        if total == 0:
            return {
                "total_questions": 0,
                "average_rating": 0,
                "max_rating": 0,
                "min_rating": 0,
                "questions": []
            }
        
        avg_rating = sum(q["elo_rating"]["current_rating"] for q in questions) / total
        max_rating = max(q["elo_rating"]["current_rating"] for q in questions)
        min_rating = min(q["elo_rating"]["current_rating"] for q in questions)
        
        return {
            "total_questions": total,
            "average_rating": round(avg_rating, 1),
            "max_rating": max_rating,
            "min_rating": min_rating,
            "questions": [
                {
                    "id": q["local_id"],
                    "question": q["content"]["question"]["fi"],
                    "rating": q["elo_rating"]["current_rating"],
                    "category": q["content"]["category"],
                    "delta": q["elo_rating"].get("comparison_delta", 0)
                }
                for q in sorted(questions, key=lambda x: x["elo_rating"]["current_rating"], reverse=True)
            ]
        }
    
    def get_leaderboard(self, top_n: int = 10):
        """Hae kysymysten ranking-lista"""
        stats = self.get_question_stats()
        return stats["questions"][:top_n]
    
    def reset_ratings(self):
        """Nollaa kaikki ELO-luokitukset"""
        with open("data/runtime/questions.json", "r") as f:
            data = json.load(f)
        
        for question in data["questions"]:
            question["elo_rating"]["current_rating"] = 1000
            question["elo_rating"]["comparison_delta"] = 0
            question["elo_rating"]["vote_delta"] = 0
        
        with open("data/runtime/questions.json", "w") as f:
            json.dump(data, f, indent=2)
        
        return len(data["questions"])
```

## src/managers/init.py
```python
"""
Manager modules for different system components
"""
```

## src/managers/analytics_manager.py
```python
#!/usr/bin/env python3
"""
Analytics ja tilastojen hallinta
"""
import json
import os
from datetime import datetime
from typing import Dict, List, Any
from pathlib import Path

class AnalyticsManager:
    def __init__(self, election_id: str):
        self.election_id = election_id
        self.data_dir = Path("data/runtime")
    
    def get_system_stats(self) -> Dict[str, Any]:
        """Hae j√§rjestelm√§n tilastot"""
        stats = {
            "election_id": self.election_id,
            "generated_at": datetime.now().isoformat(),
            "file_stats": {},
            "content_stats": {}
        }
        
        # Tiedostotilastot
        files = [
            "meta.json", "system_chain.json", "questions.json", 
            "candidates.json", "parties.json"
        ]
        
        for file in files:
            file_path = self.data_dir / file
            if file_path.exists():
                with open(file_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                stats["file_stats"][file] = {
                    "exists": True,
                    "size_kb": round(file_path.stat().st_size / 1024, 2),
                    "last_modified": datetime.fromtimestamp(file_path.stat().st_mtime).isoformat()
                }
                
                # Sis√§lt√∂tilastot
                if file == "questions.json":
                    stats["content_stats"]["questions"] = len(data.get("questions", []))
                    if data.get("questions"):
                        ratings = [q.get("elo_rating", {}).get("current_rating", 1000) for q in data["questions"]]
                        stats["content_stats"]["avg_elo_rating"] = round(sum(ratings) / len(ratings), 1)
                        stats["content_stats"]["min_elo_rating"] = min(ratings)
                        stats["content_stats"]["max_elo_rating"] = max(ratings)
                
                elif file == "candidates.json":
                    candidates = data.get("candidates", [])
                    stats["content_stats"]["candidates"] = len(candidates)
                    
                    # Vastaustilastot
                    total_answers = sum(len(c.get("answers", [])) for c in candidates)
                    candidates_with_answers = sum(1 for c in candidates if c.get("answers"))
                    stats["content_stats"]["total_answers"] = total_answers
                    stats["content_stats"]["candidates_with_answers"] = candidates_with_answers
                    if candidates:
                        stats["content_stats"]["answer_coverage_percent"] = round(
                            (candidates_with_answers / len(candidates)) * 100, 1
                        )
                
                elif file == "parties.json":
                    parties = data.get("parties", [])
                    stats["content_stats"]["parties"] = len(parties)
                    stats["content_stats"]["verified_parties"] = len(
                        [p for p in parties if p.get("registration", {}).get("verification_status") == "verified"]
                    )
                    stats["content_stats"]["pending_parties"] = len(
                        [p for p in parties if p.get("registration", {}).get("verification_status") == "pending"]
                    )
            else:
                stats["file_stats"][file] = {"exists": False}
        
        return stats
    
    def get_question_analytics(self) -> Dict[str, Any]:
        """Hae kysymysten analytics-tiedot"""
        questions_file = self.data_dir / "questions.json"
        if not questions_file.exists():
            return {}
        
        with open(questions_file, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        questions = data.get("questions", [])
        if not questions:
            return {}
        
        # Kysymysten analytics
        analytics = {
            "total_questions": len(questions),
            "categories": {},
            "elo_distribution": {
                "top_5": [],
                "bottom_5": []
            }
        }
        
        # Kategoriat
        for question in questions:
            category = question.get("content", {}).get("category", "unknown")
            analytics["categories"][category] = analytics["categories"].get(category, 0) + 1
        
        # ELO-jakauma
        sorted_questions = sorted(questions, key=lambda x: x.get("elo_rating", {}).get("current_rating", 1000), reverse=True)
        
        analytics["elo_distribution"]["top_5"] = [
            {
                "id": q["local_id"],
                "question": q["content"]["question"]["fi"],
                "rating": q["elo_rating"]["current_rating"],
                "category": q["content"]["category"]
            }
            for q in sorted_questions[:5]
        ]
        
        analytics["elo_distribution"]["bottom_5"] = [
            {
                "id": q["local_id"], 
                "question": q["content"]["question"]["fi"],
                "rating": q["elo_rating"]["current_rating"],
                "category": q["content"]["category"]
            }
            for q in sorted_questions[-5:]
        ]
        
        return analytics
    
    def generate_health_report(self) -> Dict[str, Any]:
        """Luo j√§rjestelm√§n terveysraportti"""
        stats = self.get_system_stats()
        question_analytics = self.get_question_analytics()
        
        report = {
            "election_id": self.election_id,
            "report_generated": datetime.now().isoformat(),
            "system_health": "healthy",
            "issues": [],
            "recommendations": []
        }
        
        # Tarkista ongelmat
        if stats["content_stats"].get("candidates", 0) == 0:
            report["issues"].append("Ei ehdokkaita")
            report["recommendations"].append("Lis√§√§ ehdokkaita manage_candidates.py:ll√§")
        
        if stats["content_stats"].get("questions", 0) < 2:
            report["issues"].append("Liian v√§h√§n kysymyksi√§ ELO-vertailuun")
            report["recommendations"].append("Lis√§√§ v√§hint√§√§n 2 kysymyst√§")
        
        if stats["content_stats"].get("answer_coverage_percent", 0) < 50:
            report["issues"].append("Alhainen vastauskattavuus")
            report["recommendations"].append("Kannusta ehdokkaita vastaamaan kysymyksiin")
        
        if report["issues"]:
            report["system_health"] = "needs_attention"
        
        report["stats"] = stats
        report["question_analytics"] = question_analytics
        
        return report
```

## src/managers/__init__.py
```python
```

## src/managers/divine_manager.py
```python
"""
Erikoistoiminnallisuus Jumaltenvaaleille
"""
from typing import List, Dict

class DivineManager:
    def __init__(self, election_id: str):
        self.election_id = election_id
        self.divine_domains = [
            "sky_thunder", "sea_earthquakes", "wisdom_warfare", 
            "love_beauty", "war_strategy", "hunting_nature"
        ]
    
    def validate_divine_candidate(self, candidate_data: Dict) -> bool:
        """Varmista ett√§ ehdokas on kelvollinen jumala"""
        required_fields = ["domain", "symbol", "divine_power_level"]
        
        for field in required_fields:
            if field not in candidate_data:
                return False
        
        if candidate_data["domain"] not in self.divine_domains:
            return False
            
        return True
    
    def get_olympian_quorum(self) -> int:
        """Laske tarvittava Olympos-kvoorumi"""
        return 12  # Perinteinen Olympolaisten lukum√§√§r√§
```

## src/managers/ipfs_manager.py
```python
```

## src/core/file_utils.py
```python
import json
from pathlib import Path

def read_json_file(file_path):
    """Lue JSON-tiedosto"""
    with open(file_path, 'r', encoding='utf-8') as f:
        return json.load(f)

def write_json_file(file_path, data):
    """Kirjoita JSON-tiedosto"""
    Path(file_path).parent.mkdir(parents=True, exist_ok=True)
    with open(file_path, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=2, ensure_ascii=False)
```

## src/core/election_validator.py
```python
"""Vaalidien validointi ja tarkistus"""
from .error_handling import validate_election_exists, validate_answer_value, validate_confidence_level

class ElectionValidator:
    @staticmethod
    def validate_candidate_exists(candidate_id: str, data_manager):
        """Tarkista ett√§ ehdokas on olemassa"""
        candidates = data_manager.get_candidates()
        return any(c["candidate_id"] == candidate_id for c in candidates.get("candidates", []))
    
    @staticmethod
    def validate_question_exists(question_id: str, data_manager):
        """Tarkista ett√§ kysymys on olemassa"""
        questions = data_manager.get_questions()
        return any(q["local_id"] == question_id for q in questions.get("questions", []))

```

## src/core/init.py
```python
"""
Core utilities for decentralized candidate matcher
"""
from .file_utils import read_json_file, write_json_file, calculate_fingerprint
from .ipfs_client import IPFSClient
from .config_manager import ConfigManager

__all__ = [
    'read_json_file', 
    'write_json_file', 
    'calculate_fingerprint',
    'IPFSClient',
    'ConfigManager'
]
```

## src/core/__init__.py
```python
```

## src/core/data_manager.py
```python
"""Keskitetty data-hallinta kaikille moduuleille"""
import json
from pathlib import Path
from typing import Dict, Any
from .error_handling import safe_json_read, safe_json_write

class DataManager:
    def __init__(self, election_id: str):
        self.election_id = election_id
        self.data_dir = Path(f"data/runtime/{election_id}")
        self.data_dir.mkdir(parents=True, exist_ok=True)
    
    def load_data(self, filename: str) -> Dict[str, Any]:
        """Lataa data-tiedosto"""
        file_path = self.data_dir / filename
        return safe_json_read(str(file_path))
    
    def save_data(self, filename: str, data: Dict[str, Any]):
        """Tallenna data-tiedosto"""
        file_path = self.data_dir / filename
        safe_json_write(str(file_path), data)
    
    def get_questions(self):
        return self.load_data("questions.json")
    
    def get_candidates(self):
        return self.load_data("candidates.json")
    
    def get_parties(self):
        return self.load_data("parties.json")
```

## src/core/ipfs_client.py
```python
import ipfshttpclient
from typing import Optional

class MockIPFSClient:
    """Mock IPFS client for testing"""
    def add_json(self, data):
        return {'Hash': f'mock_cid_{hash(str(data))}'}
    
    def get_json(self, cid):
        return {'mock': 'data'}

class IPFSClient:
    _instance: Optional['IPFSClient'] = None
    
    def __init__(self):
        self._client = None
        self._connect()
    
    def _connect(self):
        """Yhdist√§ IPFS:√§√§n tai k√§yt√§ mockia"""
        try:
            self._client = ipfshttpclient.connect()
        except Exception:
            self._client = MockIPFSClient()
    
    @classmethod
    def get_client(cls) -> 'IPFSClient':
        if cls._instance is None:
            cls._instance = IPFSClient()
        return cls._instance
    
    def add_data(self, data: dict) -> str:
        """Lis√§√§ data IPFS:√§√§n ja palauta CID"""
        result = self._client.add_json(data)
        return result['Hash']
    
    def get_data(self, cid: str) -> dict:
        """Hae data IPFS:st√§ CID:ll√§"""
        return self._client.get_json(cid)
```

## src/core/config_manager.py
```python
```

## src/core/error_handling.py
```python
#!/usr/bin/env python3
"""
Yhteiset virheenk√§sittelyfunktiot
"""
import sys
import json
import click
from pathlib import Path

class ElectionSystemError(Exception):
    """Perusvirheluokka vaalij√§rjestelm√§lle"""
    pass

class FileNotFoundError(ElectionSystemError):
    """Tiedostoa ei l√∂ydy"""
    pass

class DataValidationError(ElectionSystemError):
    """Data validointivirhe"""
    pass

class ElectionNotFoundError(ElectionSystemError):
    """Vaalia ei l√∂ydy"""
    pass

def handle_file_errors(func):
    """Decorator tiedostok√§sittelyvirheille"""
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except FileNotFoundError as e:
            click.echo(f"‚ùå Tiedostovirhe: {e}")
            sys.exit(1)
        except json.JSONDecodeError as e:
            click.echo(f"‚ùå JSON-virhe tiedostossa: {e}")
            sys.exit(1)
        except PermissionError as e:
            click.echo(f"‚ùå K√§ytt√∂oikeusvirhe: {e}")
            sys.exit(1)
        except Exception as e:
            click.echo(f"‚ùå Odottamaton virhe: {e}")
            sys.exit(1)
    return wrapper

def validate_election_exists(election_id: str):
    """Varmista ett√§ vaali on olemassa"""
    meta_file = Path(f"data/runtime/meta.json")
    if not meta_file.exists():
        raise ElectionNotFoundError(f"J√§rjestelm√§√§ ei ole asennettu vaaliin: {election_id}")
    
    with open(meta_file, 'r', encoding='utf-8') as f:
        meta_data = json.load(f)
    
    if meta_data.get("metadata", {}).get("election_id") != election_id:
        raise ElectionNotFoundError(f"Vaalia ei l√∂ydy: {election_id}")

def safe_json_read(file_path: str) -> dict:
    """Turvallinen JSON-tiedoston lukeminen"""
    path = Path(file_path)
    if not path.exists():
        raise FileNotFoundError(f"Tiedostoa ei l√∂ydy: {file_path}")
    
    try:
        with open(path, 'r', encoding='utf-8') as f:
            return json.load(f)
    except json.JSONDecodeError as e:
        raise DataValidationError(f"Virheellinen JSON tiedostossa {file_path}: {e}")

def safe_json_write(file_path: str, data: dict):
    """Turvallinen JSON-tiedoston kirjoitus"""
    path = Path(file_path)
    path.parent.mkdir(parents=True, exist_ok=True)
    
    try:
        with open(path, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
    except Exception as e:
        raise DataValidationError(f"Kirjoitusvirhe tiedostoon {file_path}: {e}")

def validate_answer_value(value: int) -> bool:
    """Varmista ett√§ vastaus on validi"""
    return -5 <= value <= 5

def validate_confidence_level(confidence: int) -> bool:
    """Varmista ett√§ luottamustaso on validi"""
    return 1 <= confidence <= 5
```

## src/__init__.py
```python
# Lis√§√§ src/__init__.py
import sys
from pathlib import Path
sys.path.append(str(Path(__file__).parent))

# Tai k√§yt√§ relative importteja
from ..managers.elo_manager import ELOManager
```

## src/cli/elo_admin.py
```python
#!/usr/bin/env python3
import click
import sys
import os

sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

from managers.elo_manager import ELOManager

@click.group()
def elo_admin():
    """ELO-luokituksen hallintaty√∂kalu"""
    pass

@elo_admin.command()
@click.option('--election', required=True, help='Vaalin tunniste')
def stats(election):
    """N√§yt√§ ELO-tilastot"""
    elo = ELOManager(election)
    stats = elo.get_question_stats()
    
    click.echo("üìä ELO-LUOKITUSTILASTOT")
    click.echo("=" * 50)
    click.echo(f"Kysymyksi√§ yhteens√§: {stats['total_questions']}")
    click.echo(f"Keskim√§√§r√§inen luokitus: {stats['average_rating']}")
    click.echo(f"Korkein luokitus: {stats['max_rating']}")
    click.echo(f"Matalin luokitus: {stats['min_rating']}")
    
    click.echo()
    click.echo("üèÜ TOP 10 KYSYMYS:")
    for i, question in enumerate(stats['questions'][:10], 1):
        delta_str = f" ({question['delta']:+.0f})" if question['delta'] != 0 else ""
        click.echo(f"{i:2d}. [{question['rating']:4d}{delta_str}] {question['question']}")

@elo_admin.command()
@click.option('--election', required=True, help='Vaalin tunniste')
def leaderboard(election):
    """N√§yt√§ ranking-lista"""
    elo = ELOManager(election)
    leaderboard = elo.get_leaderboard()
    
    click.echo("üèÜ ELO-RANKINGLISTA")
    click.echo("=" * 50)
    
    for i, question in enumerate(leaderboard, 1):
        delta_str = f" ({question['delta']:+.0f})" if question['delta'] != 0 else ""
        click.echo(f"{i:2d}. ‚≠ê {question['rating']:4d}{delta_str} | {question['category']:12} | {question['question']}")

@elo_admin.command()
@click.option('--election', required=True, help='Vaalin tunniste')
@click.confirmation_option(prompt='Haluatko varmasti nollata kaikki ELO-luokitukset?')
def reset(election):
    """Nollaa kaikki ELO-luokitukset"""
    elo = ELOManager(election)
    count = elo.reset_ratings()
    
    click.echo(f"‚úÖ ELO-luokitukset nollattu {count} kysymykselle")
    click.echo("üìä Kaikki kysymykset palautettu 1000 pisteen luokitukseen")

if __name__ == '__main__':
    elo_admin()
```

## src/cli/validate_data.py
```python
#!/usr/bin/env python3
"""
Data validointity√∂kalu
"""
import click
import json
import os
from pathlib import Path

@click.command()
@click.option('--election', required=True, help='Vaalin tunniste')
@click.option('--fix', is_flag=True, help='Korjaa automaattisesti l√∂ydetyt ongelmat')
def validate_data(election, fix):
    """Validoi kaikki data-tiedostot"""
    
    click.echo("üîç DATA VALIDOINTI")
    click.echo("=" * 50)
    
    files_to_check = [
        f"data/runtime/meta.json",
        f"data/runtime/system_chain.json", 
        f"data/runtime/questions.json",
        f"data/runtime/candidates.json",
        f"data/runtime/parties.json"
    ]
    
    issues_found = 0
    fixed_issues = 0
    
    for file_path in files_to_check:
        if not os.path.exists(file_path):
            click.echo(f"‚ùå Tiedostoa puuttuu: {file_path}")
            issues_found += 1
            continue
        
        try:
            # Yrit√§ lukea JSON
            with open(file_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            # Tarkista perusrakenteet
            if "metadata" not in data and file_path != "data/runtime/system_chain.json":
                click.echo(f"‚ö†Ô∏è  Puuttuu metadata: {file_path}")
                issues_found += 1
                
                if fix and file_path == "data/runtime/questions.json":
                    data["metadata"] = {"election_id": election}
                    with open(file_path, 'w', encoding='utf-8') as f:
                        json.dump(data, f, indent=2, ensure_ascii=False)
                    click.echo(f"‚úÖ Korjattu: {file_path}")
                    fixed_issues += 1
            
            click.echo(f"‚úÖ {file_path} - OK")
            
        except json.JSONDecodeError as e:
            click.echo(f"‚ùå Virheellinen JSON: {file_path} - {e}")
            issues_found += 1
    
    click.echo()
    click.echo("üìä VALIDOINTITULOKSET:")
    click.echo(f"   Tarkistetut tiedostot: {len(files_to_check)}")
    click.echo(f"   Ongelmia l√∂ydetty: {issues_found}")
    if fix:
        click.echo(f"   Korjattuja ongelmia: {fixed_issues}")
    
    if issues_found == 0:
        click.echo("üéâ Kaikki data-tiedostot ovat validit!")
    else:
        click.echo("üí° K√§yt√§ --fix yritt√§√§ksesi korjata ongelmat automaattisesti")

if __name__ == '__main__':
    validate_data()
```

## src/cli/manage_answers.py
```python
#!/usr/bin/env python3
import click
import json
import sys
import os
from datetime import datetime

sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

@click.group()
def manage_answers():
    """Ehdokkaiden vastausten hallinta"""
    pass

@manage_answers.command()
@click.option('--election', required=True, help='Vaalin tunniste')
@click.option('--candidate-id', required=True, help='Ehdokkaan tunniste')
@click.option('--question-id', required=True, help='Kysymyksen tunniste')
@click.option('--answer', type=click.IntRange(-5, 5), required=True, help='Vastaus (-5 - +5)')
@click.option('--confidence', type=click.IntRange(1, 5), default=3, help='Varmuus taso (1-5)')
@click.option('--explanation-fi', help='Perustelu suomeksi')
@click.option('--explanation-en', help='Perustelu englanniksi')
@click.option('--explanation-sv', help='Perustelu ruotsiksi')
def add(election, candidate_id, question_id, answer, confidence, explanation_fi, explanation_en, explanation_sv):
    """Lis√§√§ ehdokkaan vastaus kysymykseen"""
    
    # Tarkista ett√§ ehdokas on olemassa
    candidates_file = f"data/runtime/candidates.json"
    if not os.path.exists(candidates_file):
        click.echo("‚ùå Ehdokasrekisteri√§ ei ole viel√§ luotu")
        return
    
    with open(candidates_file, 'r', encoding='utf-8') as f:
        candidates_data = json.load(f)
    
    candidate = next((c for c in candidates_data["candidates"] if c["candidate_id"] == candidate_id), None)
    if not candidate:
        click.echo(f"‚ùå Ehdokasta '{candidate_id}' ei l√∂ydy")
        click.echo("üí° K√§yt√§: python src/cli/manage_candidates.py --election Jumaltenvaalit2026 --list")
        return
    
    # Tarkista ett√§ kysymys on olemassa
    questions_file = f"data/runtime/questions.json"
    if not os.path.exists(questions_file):
        click.echo("‚ùå Kysymysrekisteri√§ ei ole viel√§ luotu")
        return
    
    with open(questions_file, 'r', encoding='utf-8') as f:
        questions_data = json.load(f)
    
    question = next((q for q in questions_data["questions"] if q["local_id"] == question_id), None)
    if not question:
        click.echo(f"‚ùå Kysymyst√§ '{question_id}' ei l√∂ydy")
        click.echo("üí° K√§yt√§: python src/cli/manage_questions.py --election Jumaltenvaalit2026 --list")
        return
    
    # Luo tai p√§ivit√§ vastaus
    if "answers" not in candidate:
        candidate["answers"] = []
    
    # Tarkista onko vastaus jo olemassa
    existing_answer = next((a for a in candidate["answers"] if a["question_id"] == question_id), None)
    
    if existing_answer:
        # P√§ivit√§ olemassa oleva vastaus
        existing_answer["answer_value"] = answer
        existing_answer["confidence"] = confidence
        existing_answer["last_updated"] = datetime.now().isoformat()
        
        if explanation_fi:
            existing_answer["explanation"]["fi"] = explanation_fi
        if explanation_en:
            existing_answer["explanation"]["en"] = explanation_en
        if explanation_sv:
            existing_answer["explanation"]["sv"] = explanation_sv
            
        action = "p√§ivitetty"
    else:
        # Luo uusi vastaus
        new_answer = {
            "question_id": question_id,
            "answer_value": answer,
            "confidence": confidence,
            "explanation": {
                "fi": explanation_fi or "",
                "en": explanation_en or "",
                "sv": explanation_sv or ""
            },
            "created": datetime.now().isoformat(),
            "last_updated": datetime.now().isoformat()
        }
        candidate["answers"].append(new_answer)
        action = "lis√§tty"
    
    # Tallenna
    with open(candidates_file, 'w', encoding='utf-8') as f:
        json.dump(candidates_data, f, indent=2, ensure_ascii=False)
    
    click.echo(f"‚úÖ Vastaus {action}: {candidate_id} ‚Üí {question_id}")
    click.echo(f"üìä Arvo: {answer}/5, Varmuus: {confidence}/5")
    if explanation_fi:
        click.echo(f"üí¨ Perustelu: {explanation_fi}")

@manage_answers.command()
@click.option('--election', required=True, help='Vaalin tunniste')
@click.option('--candidate-id', help='N√§yt√§ tietyn ehdokkaan vastaukset')
@click.option('--question-id', help='N√§yt√§ tietyn kysymyksen vastaukset')
def list(election, candidate_id, question_id):
    """Listaa ehdokkaiden vastaukset"""
    
    candidates_file = f"data/runtime/candidates.json"
    questions_file = f"data/runtime/questions.json"
    
    if not os.path.exists(candidates_file):
        click.echo("‚ùå Ehdokasrekisteri√§ ei ole viel√§ luotu")
        return
    
    with open(candidates_file, 'r', encoding='utf-8') as f:
        candidates_data = json.load(f)
    
    # Lataa kysymykset nime√§ varten
    questions_map = {}
    if os.path.exists(questions_file):
        with open(questions_file, 'r', encoding='utf-8') as f:
            questions_data = json.load(f)
        questions_map = {q["local_id"]: q["content"]["question"]["fi"] for q in questions_data["questions"]}
    
    if candidate_id:
        # N√§yt√§ tietyn ehdokkaan vastaukset
        candidate = next((c for c in candidates_data["candidates"] if c["candidate_id"] == candidate_id), None)
        if not candidate:
            click.echo(f"‚ùå Ehdokasta '{candidate_id}' ei l√∂ydy")
            return
        
        click.echo(f"üìù EHDOKKAAN {candidate_id} VASTAUKSET")
        click.echo("=" * 50)
        
        if "answers" not in candidate or not candidate["answers"]:
            click.echo("‚ùå Ei vastauksia")
            return
        
        for answer in candidate["answers"]:
            question_text = questions_map.get(answer["question_id"], answer["question_id"])
            click.echo(f"‚ùì {question_text}")
            click.echo(f"   üìä Vastaus: {answer['answer_value']}/5")
            click.echo(f"   üéØ Varmuus: {answer['confidence']}/5")
            if answer["explanation"]["fi"]:
                click.echo(f"   üí¨ Perustelu: {answer['explanation']['fi']}")
            click.echo()
    
    elif question_id:
        # N√§yt√§ tietyn kysymyksen vastaukset
        click.echo(f"üìù KYSYMYKSEN {question_id} VASTAUKSET")
        click.echo("=" * 50)
        
        question_text = questions_map.get(question_id, question_id)
        click.echo(f"Kysymys: {question_text}")
        click.echo()
        
        found_answers = False
        for candidate in candidates_data["candidates"]:
            if "answers" in candidate:
                answer = next((a for a in candidate["answers"] if a["question_id"] == question_id), None)
                if answer:
                    found_answers = True
                    click.echo(f"üë§ {candidate['basic_info']['name']['fi']} ({candidate['candidate_id']})")
                    click.echo(f"   üìä Vastaus: {answer['answer_value']}/5")
                    click.echo(f"   üéØ Varmuus: {answer['confidence']}/5")
                    if answer["explanation"]["fi"]:
                        click.echo(f"   üí¨ Perustelu: {answer['explanation']['fi']}")
                    click.echo()
        
        if not found_answers:
            click.echo("‚ùå Ei vastauksia t√§h√§n kysymykseen")
    
    else:
        # N√§yt√§ kaikkien ehdokkaiden yhteenveto
        click.echo("üìä EHDOKKAIDEN VASTAUSYHTEENVETO")
        click.echo("=" * 50)
        
        total_answers = 0
        candidates_with_answers = 0
        
        for candidate in candidates_data["candidates"]:
            answer_count = len(candidate.get("answers", []))
            total_answers += answer_count
            if answer_count > 0:
                candidates_with_answers += 1
            
            candidate_name = candidate["basic_info"]["name"]["fi"]
            click.echo(f"üë§ {candidate_name} ({candidate['candidate_id']}): {answer_count} vastausta")
        
        click.echo()
        click.echo(f"üìà YHTEENVETO:")
        click.echo(f"   Ehdokkaita: {len(candidates_data['candidates'])}")
        click.echo(f"   Vastanneita: {candidates_with_answers}")
        click.echo(f"   Vastauksia yhteens√§: {total_answers}")
        
        if len(candidates_data["candidates"]) > 0:
            coverage = (candidates_with_answers / len(candidates_data["candidates"])) * 100
            click.echo(f"   Vastauskattavuus: {coverage:.1f}%")

@manage_answers.command()
@click.option('--election', required=True, help='Vaalin tunniste')
@click.option('--candidate-id', required=True, help='Ehdokkaan tunniste')
@click.option('--question-id', required=True, help='Kysymyksen tunniste')
def remove(election, candidate_id, question_id):
    """Poista ehdokkaan vastaus"""
    
    candidates_file = f"data/runtime/candidates.json"
    if not os.path.exists(candidates_file):
        click.echo("‚ùå Ehdokasrekisteri√§ ei ole viel√§ luotu")
        return
    
    with open(candidates_file, 'r', encoding='utf-8') as f:
        candidates_data = json.load(f)
    
    candidate = next((c for c in candidates_data["candidates"] if c["candidate_id"] == candidate_id), None)
    if not candidate:
        click.echo(f"‚ùå Ehdokasta '{candidate_id}' ei l√∂ydy")
        return
    
    if "answers" not in candidate:
        click.echo("‚ùå Ehdokkaalla ei ole vastauksia")
        return
    
    # Etsi ja poista vastaus
    initial_count = len(candidate["answers"])
    candidate["answers"] = [a for a in candidate["answers"] if a["question_id"] != question_id]
    
    if len(candidate["answers"]) == initial_count:
        click.echo(f"‚ùå Vastausta ei l√∂ytynyt: {candidate_id} ‚Üí {question_id}")
        return
    
    # Tallenna
    with open(candidates_file, 'w', encoding='utf-8') as f:
        json.dump(candidates_data, f, indent=2, ensure_ascii=False)
    
    click.echo(f"‚úÖ Vastaus poistettu: {candidate_id} ‚Üí {question_id}")
    click.echo(f"üìä Ehdokkaalla on nyt {len(candidate['answers'])} vastausta")

if __name__ == '__main__':
    manage_answers()
```

## src/cli/manage_candidates.py
```python
#!/usr/bin/env python3
import click
import json
from datetime import datetime
import os

@click.command()
@click.option('--election', required=True, help='Vaalin tunniste')
@click.option('--add', is_flag=True, help='Lis√§√§ uusi ehdokas')
@click.option('--name', help='Ehdokkaan nimi')
@click.option('--party', help='Puolue')
def manage_candidates(election, add, name, party):
    """Hallinnoi vaaliehdokkaita"""
    
    if add:
        if not name:
            click.echo("‚ùå Anna --name")
            return
        
        # Lataa nykyiset ehdokkaat
        candidates_file = f"data/runtime/candidates.json"
        if os.path.exists(candidates_file):
            with open(candidates_file, 'r') as f:
                data = json.load(f)
        else:
            data = {"candidates": [], "metadata": {"election_id": election}}
        
        # Lis√§√§ uusi ehdokas
        new_candidate = {
            "candidate_id": f"cand_{len(data['candidates']) + 1}",
            "basic_info": {
                "name": {
                    "fi": name,
                    "en": f"[EN] {name}",
                    "sv": f"[SV] {name}"
                },
                "party": party or "sitoutumaton",
                "domain": "divine_power"  # Jumaltenvaalien erikoisala
            },
            "answers": []
        }
        
        data["candidates"].append(new_candidate)
        
        # Tallenna
        with open(candidates_file, 'w') as f:
            json.dump(data, f, indent=2)
        
        click.echo(f"‚úÖ Ehdokas lis√§tty: {name}")
        click.echo(f"üëë Ehdokkaita yhteens√§: {len(data['candidates'])}")

if __name__ == '__main__':
    manage_candidates()
```

## src/cli/compare_questions.py
```python
#!/usr/bin/env python3
import click
import random
import json
import sys
import os

sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

try:
    from managers.elo_manager import ELOManager
except ImportError:
    # Fallback simple implementation
    class ELOManager:
        def __init__(self, election_id: str):
            self.election_id = election_id
            self.k_factor = 32
        
        def calculate_expected(self, rating_a: int, rating_b: int) -> float:
            return 1 / (1 + 10 ** ((rating_b - rating_a) / 400))
        
        def update_ratings(self, question_a: str, question_b: str, winner: str):
            with open("data/runtime/questions.json", "r") as f:
                data = json.load(f)
            
            q_a = next((q for q in data["questions"] if q["local_id"] == question_a), None)
            q_b = next((q for q in data["questions"] if q["local_id"] == question_b), None)
            
            if not q_a or not q_b:
                raise ValueError("Kysymyksi√§ ei l√∂ydy")
            
            rating_a = q_a["elo_rating"]["current_rating"]
            rating_b = q_b["elo_rating"]["current_rating"]
            
            expected_a = self.calculate_expected(rating_a, rating_b)
            expected_b = self.calculate_expected(rating_b, rating_a)
            
            if winner == "a":
                actual_a, actual_b = 1.0, 0.0
            elif winner == "b":
                actual_a, actual_b = 0.0, 1.0
            else:
                actual_a, actual_b = 0.5, 0.5
            
            new_rating_a = rating_a + self.k_factor * (actual_a - expected_a)
            new_rating_b = rating_b + self.k_factor * (actual_b - expected_b)
            
            q_a["elo_rating"]["current_rating"] = int(new_rating_a)
            q_a["elo_rating"]["comparison_delta"] = int(new_rating_a - rating_a)
            q_b["elo_rating"]["current_rating"] = int(new_rating_b)
            q_b["elo_rating"]["comparison_delta"] = int(new_rating_b - rating_b)
            
            with open("data/runtime/questions.json", "w") as f:
                json.dump(data, f, indent=2)
            
            return {
                "question_a": {"old": rating_a, "new": new_rating_a, "delta": new_rating_a - rating_a},
                "question_b": {"old": rating_b, "new": new_rating_b, "delta": new_rating_b - rating_b}
            }

@click.command()
@click.option('--election', required=True, help='Vaalin tunniste')
@click.option('--choice', help='Valinta (a/b/t) - jos annettu, ei kysy interaktiivisesti')
def compare_questions(election, choice):
    """Vertaa kahta satunnaista kysymyst√§ kesken√§√§n"""
    
    # Lataa kysymykset
    with open("data/runtime/questions.json", "r") as f:
        data = json.load(f)
    
    if len(data["questions"]) < 2:
        click.echo("‚ùå Tarvitaan v√§hint√§√§n 2 kysymyst√§ vertailuun")
        return
    
    # Valitse kaksi satunnaista kysymyst√§
    q1, q2 = random.sample(data["questions"], 2)
    
    click.echo("üîç VERTAA KYSYMYKSI√Ñ")
    click.echo("=" * 50)
    click.echo(f"A) {q1['content']['question']['fi']}")
    click.echo(f"   Luokitus: {q1['elo_rating']['current_rating']}")
    click.echo("")
    click.echo(f"B) {q2['content']['question']['fi']}") 
    click.echo(f"   Luokitus: {q2['elo_rating']['current_rating']}")
    click.echo("")
    
    # Hae valinta joko parametrista tai interaktiivisesti
    if choice:
        if choice.lower() in ['a', 'b', 't']:
            user_choice = choice.lower()
            click.echo(f"Automaattinen valinta: {user_choice}")
        else:
            click.echo("‚ùå Virheellinen valinta parametrissa, k√§ytet√§√§n interaktiivista")
            user_choice = click.prompt("Kumpi on t√§rke√§mpi? (a/b/tasapeli)", type=click.Choice(['a', 'b', 't']))
    else:
        user_choice = click.prompt("Kumpi on t√§rke√§mpi? (a/b/tasapeli)", type=click.Choice(['a', 'b', 't']))
    
    # P√§ivit√§ ELO-luokitukset
    elo_manager = ELOManager(election)
    result = elo_manager.update_ratings(q1["local_id"], q2["local_id"], user_choice)
    
    click.echo("")
    click.echo("‚úÖ Luokitukset p√§ivitetty!")
    click.echo(f"üìä A: {result['question_a']['old']} ‚Üí {result['question_a']['new']} ({result['question_a']['delta']:+.0f})")
    click.echo(f"üìä B: {result['question_b']['old']} ‚Üí {result['question_b']['new']} ({result['question_b']['delta']:+.0f})")

if __name__ == '__main__':
    compare_questions()
```

## src/cli/__init__.py
```python
```

## src/cli/link_candidate_to_party.py
```python
#!/usr/bin/env python3
import click
import json
import sys
import os

sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

@click.command()
@click.option('--election', required=True, help='Vaalin tunniste')
@click.option('--candidate-id', required=True, help='Ehdokkaan tunniste')
@click.option('--party-id', required=True, help='Puolueen tunniste')
def link_candidate(election, candidate_id, party_id):
    """Liit√§ ehdokas puolueeseen"""
    
    # Tarkista ett√§ puolue on olemassa ja vahvistettu
    parties_file = f"data/runtime/parties.json"
    if not os.path.exists(parties_file):
        click.echo("‚ùå Puoluerekisteri√§ ei ole viel√§ luotu")
        return
    
    with open(parties_file, 'r') as f:
        parties_data = json.load(f)
    
    party = next((p for p in parties_data["parties"] if p["party_id"] == party_id), None)
    if not party:
        click.echo(f"‚ùå Puoluetta '{party_id}' ei l√∂ydy")
        click.echo("üí° K√§yt√§: python src/cli/manage_parties.py list --election Jumaltenvaalit2026")
        return
    
    if party["registration"]["verification_status"] != "verified":
        click.echo(f"‚ùå Puolue '{party_id}' ei ole vahvistettu")
        click.echo(f"üí° Tila: {party['registration']['verification_status']}")
        if party["registration"]["verification_status"] == "pending":
            verified_count = len(party["registration"]["verified_by"])
            needed = parties_data["quorum_config"]["min_nodes_for_verification"]
            click.echo(f"üí° Vahvistuksia: {verified_count}/{needed}")
        return
    
    # Tarkista ett√§ ehdokas on olemassa
    candidates_file = f"data/runtime/candidates.json"
    if not os.path.exists(candidates_file):
        click.echo("‚ùå Ehdokasrekisteri√§ ei ole viel√§ luotu")
        return
    
    with open(candidates_file, 'r') as f:
        candidates_data = json.load(f)
    
    candidate = next((c for c in candidates_data["candidates"] if c["candidate_id"] == candidate_id), None)
    if not candidate:
        click.echo(f"‚ùå Ehdokasta '{candidate_id}' ei l√∂ydy")
        click.echo("üí° K√§yt√§: python src/cli/manage_candidates.py --election Jumaltenvaalit2026 --add")
        return
    
    # P√§ivit√§ ehdokkaan puolue
    old_party = candidate["basic_info"].get("party", "ei puoluetta")
    candidate["basic_info"]["party"] = party_id
    
    # Lis√§√§ ehdokas puolueen listalle
    if candidate_id not in party["candidates"]:
        party["candidates"].append(candidate_id)
    
    # Tallenna molemmat tiedostot
    with open(candidates_file, 'w') as f:
        json.dump(candidates_data, f, indent=2)
    
    with open(parties_file, 'w') as f:
        json.dump(parties_data, f, indent=2)
    
    click.echo(f"‚úÖ Ehdokas {candidate_id} liitetty puolueeseen {party_id}")
    click.echo(f"üìù Aiempi puolue: {old_party}")
    click.echo(f"üëë Puolueessa nyt {len(party['candidates'])} ehdokasta")

if __name__ == '__main__':
    link_candidate()
```

## src/cli/party_stats.py
```python
#!/usr/bin/env python3
import click
import json
import os

@click.command()
@click.option('--election', required=True, help='Vaalin tunniste')
def party_stats(election):
    """N√§yt√§ puolueiden tilastot"""
    
    parties_file = f"data/runtime/parties.json"
    candidates_file = f"data/runtime/candidates.json"
    
    if not os.path.exists(parties_file):
        click.echo("‚ùå Puoluerekisteri√§ ei l√∂ydy")
        return
    
    with open(parties_file, 'r') as f:
        parties_data = json.load(f)
    
    # Lataa ehdokkaat jos saatavilla
    candidates_data = {}
    if os.path.exists(candidates_file):
        with open(candidates_file, 'r') as f:
            candidates_data = json.load(f)
    
    click.echo("üìä PUOLUETILASTOT")
    click.echo("=" * 50)
    
    verified_parties = [p for p in parties_data["parties"] if p["registration"]["verification_status"] == "verified"]
    
    if not verified_parties:
        click.echo("‚ùå Ei vahvistettuja puolueita")
        return
    
    for party in verified_parties:
        click.echo(f"üèõÔ∏è  {party['name']['fi']} ({party['party_id']})")
        click.echo(f"   üìß {party['metadata'].get('contact_email', 'Ei s√§hk√∂postia')}")
        click.echo(f"   üåê {party['metadata'].get('website', 'Ei verkkosivua')}")
        click.echo(f"   üëë Ehdokkaita: {len(party['candidates'])}")
        
        # N√§yt√§ ehdokkaat
        if candidates_data and "candidates" in candidates_data:
            party_candidates = [c for c in candidates_data["candidates"] if c["candidate_id"] in party["candidates"]]
            for cand in party_candidates:
                click.echo(f"     ‚Ä¢ {cand['basic_info']['name']['fi']}")
        
        click.echo()

if __name__ == '__main__':
    party_stats()
```

## src/cli/base_cli.py
```python
"""Perusluokka kaikille CLI-komennoille"""
import click
from src.core.data_manager import DataManager
from src.core.election_validator import ElectionValidator
from src.core.error_handling import handle_file_errors, validate_election_exists

class BaseCLI:
    def __init__(self, election_id: str):
        self.election_id = election_id
        self.data_manager = DataManager(election_id)
        self.validator = ElectionValidator()
    
    def validate_election(self):
        """Varmista ett√§ vaali on olemassa"""
        validate_election_exists(self.election_id)
```

## src/cli/manage_questions.py
```python
#!/usr/bin/env python3
import click
import json
import sys
import os
from datetime import datetime

sys.path.append(os.path.join(os.path.dirname(__file__), '..'))
from core.error_handling import (
    handle_file_errors, validate_election_exists, 
    safe_json_read, safe_json_write, ElectionSystemError
)

@click.group()
def manage_questions():
    """Kysymysten hallinta parannetulla virheenk√§sittelyll√§"""
    pass

@manage_questions.command()
@click.option('--election', required=True, help='Vaalin tunniste')
@click.option('--add', is_flag=True, help='Lis√§√§ uusi kysymys')
@click.option('--category', help='Kysymyksen kategoria')
@click.option('--question-fi', help='Kysymys suomeksi')
@click.option('--list', 'list_questions', is_flag=True, help='Listaa kaikki kysymykset')
@handle_file_errors
def main(election, add, category, question_fi, list_questions):
    """P√§√§komento parannetulla virheenk√§sittelyll√§"""
    
    # Varmista ett√§ vaali on olemassa
    validate_election_exists(election)
    
    if add:
        if not category or not question_fi:
            raise click.UsageError("Anna --category ja --question-fi lis√§t√§ksesi kysymyksen")
        _add_question(election, category, question_fi)
    elif list_questions:
        _list_questions(election)
    else:
        click.echo("üí° K√§yt√§ --add lis√§t√§ksesi kysymyksen tai --list listataksesi kysymykset")

def _add_question(election_id: str, category: str, question_fi: str):
    """Lis√§√§ uusi kysymys"""
    questions_file = f"data/runtime/questions.json"
    
    # Lataa nykyiset kysymykset turvallisesti
    if os.path.exists(questions_file):
        data = safe_json_read(questions_file)
    else:
        data = {
            "questions": [],
            "metadata": {"election_id": election_id}
        }
    
    # Tarkista duplikaatit
    existing_question = next(
        (q for q in data["questions"] 
         if q["content"]["question"]["fi"].lower() == question_fi.lower()),
        None
    )
    
    if existing_question:
        raise ElectionSystemError(f"Kysymys on jo olemassa: {question_fi}")
    
    # Luo uusi kysymys
    new_question = {
        "local_id": f"q_{len(data['questions']) + 1}",
        "content": {
            "category": category,
            "question": {
                "fi": question_fi,
                "en": f"[EN] {question_fi}",
                "sv": f"[SV] {question_fi}"
            },
            "scale": {"min": -5, "max": 5}
        },
        "elo_rating": {
            "base_rating": 1000,
            "current_rating": 1000,
            "comparison_delta": 0,
            "vote_delta": 0
        },
        "timestamps": {
            "created_local": datetime.now().isoformat(),
            "modified_local": datetime.now().isoformat()
        }
    }
    
    data["questions"].append(new_question)
    
    # Tallenna turvallisesti
    safe_json_write(questions_file, data)
    
    click.echo(f"‚úÖ Kysymys lis√§tty: {question_fi}")
    click.echo(f"üìä Kysymyksi√§ yhteens√§: {len(data['questions'])}")

def _list_questions(election_id: str):
    """Listaa kaikki kysymykset"""
    questions_file = f"data/runtime/questions.json"
    
    if not os.path.exists(questions_file):
        click.echo("‚ÑπÔ∏è Ei kysymyksi√§ viel√§ lis√§tty")
        return
    
    data = safe_json_read(questions_file)
    
    click.echo("üìù KYSYMYSLISTA")
    click.echo("=" * 50)
    
    for i, question in enumerate(data["questions"], 1):
        click.echo(f"{i}. [{question['local_id']}] {question['content']['question']['fi']}")
        click.echo(f"   Kategoria: {question['content']['category']}")
        click.echo(f"   ELO-luokitus: {question['elo_rating']['current_rating']}")
        click.echo()

if __name__ == '__main__':
    main()
```

## src/cli/manage_parties.py
```python
#!/usr/bin/env python3
import click
import json
import sys
import os
from datetime import datetime

sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

@click.group()
def manage_parties():
    """Puolueiden hajautettu hallinta"""
    pass

@manage_parties.command()
@click.option('--election', required=True, help='Vaalin tunniste')
@click.option('--name-fi', required=True, help='Puolueen nimi suomeksi')
@click.option('--name-en', help='Puolueen nimi englanniksi')
@click.option('--name-sv', help='Puolueen nimi ruotsiksi')
@click.option('--description-fi', help='Puolueen kuvaus suomeksi')
@click.option('--email', help='Yhteysemail')
@click.option('--website', help='Verkkosivusto')
@click.option('--founding-year', default='2024', help='Perustamisvuosi')
def propose(election, name_fi, name_en, name_sv, description_fi, email, website, founding_year):
    """Ehdotta uutta puoluetta"""
    
    # Lataa nykyiset puolueet
    parties_file = f"data/runtime/parties.json"
    if os.path.exists(parties_file):
        with open(parties_file, 'r') as f:
            data = json.load(f)
    else:
        # Luo uusi puoluerekisteri base templatesta
        data = {
            "metadata": {
                "version": "1.0.0",
                "created": datetime.now().isoformat(),
                "last_updated": datetime.now().isoformat(),
                "election_id": election,
                "description": {
                    "fi": "Puolueiden hajautettu rekisteri",
                    "en": "Decentralized party registry",
                    "sv": "Decentraliserat partiregister"
                }
            },
            "quorum_config": {
                "min_nodes_for_verification": 3,
                "approval_threshold_percent": 60,
                "verification_timeout_hours": 24,
                "rejection_quorum_percent": 40
            },
            "parties": [],
            "verification_history": []
        }
    
    # Tarkista onko puoluetta jo olemassa
    existing_party = next((p for p in data["parties"] if p["name"]["fi"].lower() == name_fi.lower()), None)
    if existing_party:
        click.echo(f"‚ùå Puolue '{name_fi}' on jo olemassa! (ID: {existing_party['party_id']})")
        return
    
    # Luo uusi puolue
    party_id = f"party_{len(data['parties']) + 1:03d}"
    new_party = {
        "party_id": party_id,
        "name": {
            "fi": name_fi,
            "en": name_en or f"[EN] {name_fi}",
            "sv": name_sv or f"[SV] {name_fi}"
        },
        "description": {
            "fi": description_fi or f"{name_fi} - puolue",
            "en": description_fi or f"{name_fi} - party", 
            "sv": description_fi or f"{name_fi} - parti"
        },
        "registration": {
            "proposed_by": "system",  # Aluksi j√§rjestelm√§, nodet korvaavat
            "proposed_at": datetime.now().isoformat(),
            "verification_status": "pending",
            "verified_by": [],
            "verification_timestamp": None,
            "rejection_reason": None
        },
        "candidates": [],
        "metadata": {
            "official_registration": False,
            "contact_email": email,
            "website": website,
            "founding_year": founding_year
        }
    }
    
    data["parties"].append(new_party)
    data["metadata"]["last_updated"] = datetime.now().isoformat()
    
    # Lis√§√§ historiaan
    data["verification_history"].append({
        "party_id": party_id,
        "timestamp": datetime.now().isoformat(),
        "action": "proposed",
        "by_node": "system",
        "reason": "Uusi puolue ehdotettu"
    })
    
    # Tallenna
    os.makedirs(os.path.dirname(parties_file), exist_ok=True)
    with open(parties_file, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=2, ensure_ascii=False)
    
    click.echo(f"‚úÖ Puolue ehdotettu: {name_fi} ({party_id})")
    click.echo(f"üìã Tila: Odottaa vahvistusta ({data['quorum_config']['min_nodes_for_verification']} nodelta)")

@manage_parties.command()
@click.option('--election', required=True, help='Vaalin tunniste')
@click.option('--show-pending', is_flag=True, help='N√§yt√§ my√∂s odottavat puolueet')
@click.option('--show-rejected', is_flag=True, help='N√§yt√§ my√∂s hyl√§tyt puolueet')
def list(election, show_pending, show_rejected):
    """Listaa kaikki puolueet"""
    
    parties_file = f"data/runtime/parties.json"
    if not os.path.exists(parties_file):
        click.echo("‚ùå Puoluerekisteri√§ ei ole viel√§ luotu")
        click.echo("üí° K√§yt√§: python src/cli/manage_parties.py propose --election Jumaltenvaalit2026 --name-fi 'Nimi'")
        return
    
    with open(parties_file, 'r', encoding='utf-8') as f:
        data = json.load(f)
    
    click.echo("üèõÔ∏è  REKISTER√ñIDYT PUOLUEET")
    click.echo("=" * 60)
    
    verified_parties = [p for p in data["parties"] if p["registration"]["verification_status"] == "verified"]
    pending_parties = [p for p in data["parties"] if p["registration"]["verification_status"] == "pending"]
    rejected_parties = [p for p in data["parties"] if p["registration"]["verification_status"] == "rejected"]
    
    # N√§yt√§ vahvistetut puolueet
    if verified_parties:
        click.echo("\n‚úÖ VAHVISTETUT PUOLUEET:")
        for party in verified_parties:
            click.echo(f"  üèõÔ∏è  {party['name']['fi']} ({party['party_id']})")
            click.echo(f"     üìß {party['metadata'].get('contact_email', 'Ei s√§hk√∂postia')}")
            click.echo(f"     üëë Ehdokkaita: {len(party['candidates'])}")
            click.echo(f"     üïí Vahvistettu: {party['registration']['verification_timestamp'][:16]}")
            click.echo(f"     ‚úÖ Vahvistajat: {', '.join(party['registration']['verified_by'])}")
    
    # N√§yt√§ odottavat puolueet
    if pending_parties and show_pending:
        click.echo("\n‚è≥ ODOTTAA VAHVISTUSTA:")
        for party in pending_parties:
            verified_count = len(party["registration"]["verified_by"])
            needed = data["quorum_config"]["min_nodes_for_verification"]
            click.echo(f"  ‚è≥ {party['name']['fi']} ({party['party_id']})")
            click.echo(f"     üìß {party['metadata'].get('contact_email', 'Ei s√§hk√∂postia')}")
            click.echo(f"     üëë Ehdokkaita: {len(party['candidates'])}")
            click.echo(f"     ‚úÖ Vahvistuksia: {verified_count}/{needed}")
    
    elif pending_parties:
        click.echo(f"\n‚è≥ {len(pending_parties)} puoluetta odottaa vahvistusta")
        click.echo("üí° N√§yt√§ kaikki: --show-pending")
    
    # N√§yt√§ hyl√§tyt puolueet
    if rejected_parties and show_rejected:
        click.echo("\n‚ùå HYL√ÑTYT PUOLUEET:")
        for party in rejected_parties:
            click.echo(f"  ‚ùå {party['name']['fi']} ({party['party_id']})")
            click.echo(f"     üìß {party['metadata'].get('contact_email', 'Ei s√§hk√∂postia')}")
            click.echo(f"     üí¨ Syy: {party['registration']['rejection_reason']}")
    
    elif rejected_parties:
        click.echo(f"\n‚ùå {len(rejected_parties)} puoluetta hyl√§tty")
        click.echo("üí° N√§yt√§ kaikki: --show-rejected")
    
    if not verified_parties and not pending_parties and not rejected_parties:
        click.echo("‚ùå Ei puolueita rekisteriss√§")

@manage_parties.command()
@click.option('--election', required=True, help='Vaalin tunniste')
@click.option('--party-id', required=True, help='Puolueen tunniste')
@click.option('--node-id', required=True, help='Vahvistavan noden tunniste')
@click.option('--verify', is_flag=True, help='Vahvista puolue')
@click.option('--reject', is_flag=True, help='Hylk√§√§ puolue')
@click.option('--reason', help='Syy vahvistukseen/hylk√§√§miseen')
def verify(election, party_id, node_id, verify, reject, reason):
    """Vahvista tai hylk√§√§ puolue"""
    
    if verify and reject:
        click.echo("‚ùå Valitse joko --verify tai --reject, ei molempia")
        return
    
    if not verify and not reject:
        click.echo("‚ùå Valitse joko --verify tai --reject")
        return
    
    parties_file = f"data/runtime/parties.json"
    if not os.path.exists(parties_file):
        click.echo("‚ùå Puoluerekisteri√§ ei ole viel√§ luotu")
        return
    
    with open(parties_file, 'r', encoding='utf-8') as f:
        data = json.load(f)
    
    # Etsi puolue
    party = next((p for p in data["parties"] if p["party_id"] == party_id), None)
    if not party:
        click.echo(f"‚ùå Puoluetta '{party_id}' ei l√∂ydy")
        click.echo("üí° K√§yt√§: python src/cli/manage_parties.py list --election Jumaltenvaalit2026")
        return
    
    # Tarkista ett√§ node_id on annettu
    if not node_id:
        click.echo("‚ùå Anna --node-id parametri")
        return
    
    if verify:
        # Tarkista onko jo vahvistettu
        if party["registration"]["verification_status"] == "verified":
            click.echo("‚ùå Puolue on jo vahvistettu")
            return
        
        # Tarkista onko jo vahvistanut
        if node_id in party["registration"]["verified_by"]:
            click.echo("‚ùå Olet jo vahvistanut t√§m√§n puolueen")
            return
        
        # Lis√§√§ vahvistus
        party["registration"]["verified_by"].append(node_id)
        
        # Tarkista saadaanko kvoorumi
        verified_count = len(party["registration"]["verified_by"])
        needed = data["quorum_config"]["min_nodes_for_verification"]
        
        if verified_count >= needed:
            party["registration"]["verification_status"] = "verified"
            party["registration"]["verification_timestamp"] = datetime.now().isoformat()
            party["metadata"]["official_registration"] = True
            message = f"üéâ PUOLUE VAHVISTETTU! ({verified_count}/{needed} kvoorumi saavutettu)"
        else:
            message = f"‚úÖ Puolue vahvistettu ({verified_count}/{needed})"
        
        action = "verified"
        
    else:  # reject
        if party["registration"]["verification_status"] == "rejected":
            click.echo("‚ùå Puolue on jo hyl√§tty")
            return
            
        party["registration"]["verification_status"] = "rejected"
        party["registration"]["rejection_reason"] = reason or "Ei syyt√§ annettu"
        action = "rejected"
        message = f"‚ùå Puolue hyl√§tty: {reason}"
    
    # P√§ivit√§ viimeisin muokkausaika
    data["metadata"]["last_updated"] = datetime.now().isoformat()
    
    # Lis√§√§ historiaan
    data["verification_history"].append({
        "party_id": party_id,
        "timestamp": datetime.now().isoformat(),
        "action": action,
        "by_node": node_id,
        "reason": reason or "Ei syyt√§ annettu"
    })
    
    # Tallenna
    with open(parties_file, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=2, ensure_ascii=False)
    
    click.echo(message)

@manage_parties.command()
@click.option('--election', required=True, help='Vaalin tunniste')
@click.option('--party-id', required=True, help='Puolueen tunniste')
def info(election, party_id):
    """N√§yt√§ yksitt√§isen puolueen tiedot"""
    
    parties_file = f"data/runtime/parties.json"
    if not os.path.exists(parties_file):
        click.echo("‚ùå Puoluerekisteri√§ ei ole viel√§ luotu")
        return
    
    with open(parties_file, 'r', encoding='utf-8') as f:
        data = json.load(f)
    
    # Etsi puolue
    party = next((p for p in data["parties"] if p["party_id"] == party_id), None)
    if not party:
        click.echo(f"‚ùå Puoluetta '{party_id}' ei l√∂ydy")
        return
    
    click.echo(f"üèõÔ∏è  PUOLUETIEDOT: {party['name']['fi']}")
    click.echo("=" * 50)
    
    # Perustiedot
    click.echo(f"üìõ Nimi:")
    click.echo(f"   üá´üáÆ {party['name']['fi']}")
    click.echo(f"   üá¨üáß {party['name']['en']}")
    click.echo(f"   üá∏üá™ {party['name']['sv']}")
    
    click.echo(f"üìù Kuvaus:")
    click.echo(f"   üá´üáÆ {party['description']['fi']}")
    click.echo(f"   üá¨üáß {party['description']['en']}")
    click.echo(f"   üá∏üá™ {party['description']['sv']}")
    
    # Yhteystiedot
    click.echo(f"üìß Yhteystiedot:")
    click.echo(f"   S√§hk√∂posti: {party['metadata'].get('contact_email', 'Ei asetettu')}")
    click.echo(f"   Verkkosivu: {party['metadata'].get('website', 'Ei asetettu')}")
    click.echo(f"   Perustamisvuosi: {party['metadata'].get('founding_year', 'Ei asetettu')}")
    
    # Rekister√∂intitiedot
    status = party["registration"]["verification_status"]
    status_icon = "‚úÖ" if status == "verified" else "‚è≥" if status == "pending" else "‚ùå"
    
    click.echo(f"üìã Rekister√∂inti:")
    click.echo(f"   Tila: {status_icon} {status}")
    click.echo(f"   Ehdotettu: {party['registration']['proposed_at'][:16]}")
    click.echo(f"   Ehdottaja: {party['registration']['proposed_by']}")
    
    if status == "verified":
        click.echo(f"   Vahvistettu: {party['registration']['verification_timestamp'][:16]}")
        click.echo(f"   Vahvistajat: {', '.join(party['registration']['verified_by'])}")
    elif status == "rejected":
        click.echo(f"   Hylk√§yssyyt: {party['registration']['rejection_reason']}")
    else:  # pending
        verified_count = len(party["registration"]["verified_by"])
        needed = data["quorum_config"]["min_nodes_for_verification"]
        click.echo(f"   Vahvistuksia: {verified_count}/{needed}")
        if party["registration"]["verified_by"]:
            click.echo(f"   Vahvistaneet: {', '.join(party['registration']['verified_by'])}")
    
    # Ehdokkaat
    click.echo(f"üëë Ehdokkaat ({len(party['candidates'])}):")
    if party["candidates"]:
        for cand_id in party["candidates"]:
            click.echo(f"   ‚Ä¢ {cand_id}")
    else:
        click.echo("   Ei ehdokkaita")

@manage_parties.command()
@click.option('--election', required=True, help='Vaalin tunniste')
def stats(election):
    """N√§yt√§ puolueiden tilastot"""
    
    parties_file = f"data/runtime/parties.json"
    if not os.path.exists(parties_file):
        click.echo("‚ùå Puoluerekisteri√§ ei ole viel√§ luotu")
        return
    
    with open(parties_file, 'r', encoding='utf-8') as f:
        data = json.load(f)
    
    click.echo("üìä PUOLUETILASTOT")
    click.echo("=" * 50)
    
    total_parties = len(data["parties"])
    verified_parties = [p for p in data["parties"] if p["registration"]["verification_status"] == "verified"]
    pending_parties = [p for p in data["parties"] if p["registration"]["verification_status"] == "pending"]
    rejected_parties = [p for p in data["parties"] if p["registration"]["verification_status"] == "rejected"]
    
    click.echo(f"üèõÔ∏è  Puolueita yhteens√§: {total_parties}")
    click.echo(f"‚úÖ  Vahvistettuja: {len(verified_parties)}")
    click.echo(f"‚è≥  Odottaa vahvistusta: {len(pending_parties)}")
    click.echo(f"‚ùå  Hyl√§ttyj√§: {len(rejected_parties)}")
    
    # Ehdokastilastot
    total_candidates = sum(len(p["candidates"]) for p in data["parties"])
    click.echo(f"üëë  Ehdokkaita yhteens√§: {total_candidates}")
    
    if verified_parties:
        click.echo(f"üìà  Keskim√§√§rin ehdokkaita/vahvistettu puolue: {total_candidates/len(verified_parties):.1f}")
    
    # Kvoorumitilanne
    click.echo(f"üî¢  Vahvistus kvoorumi: {data['quorum_config']['min_nodes_for_verification']} nodea")
    
    # Viimeisimm√§t tapahtumat
    click.echo(f"\nüìú Viimeisimm√§t tapahtumat:")
    recent_events = data["verification_history"][-5:]
    for event in reversed(recent_events):
        action_icon = "‚úÖ" if event["action"] == "verified" else "‚ùå" if event["action"] == "rejected" else "üìù"
        click.echo(f"   {action_icon} {event['timestamp'][11:16]} - {event['party_id']}: {event['action']} ({event['by_node']})")

@manage_parties.command()
@click.option('--election', required=True, help='Vaalin tunniste')
@click.option('--party-id', required=True, help='Puolueen tunniste')
@click.confirmation_option(prompt='Haluatko varmasti poistaa t√§m√§n puolueen?')
def remove(election, party_id):
    """Poista puolue rekisterist√§"""
    
    parties_file = f"data/runtime/parties.json"
    if not os.path.exists(parties_file):
        click.echo("‚ùå Puoluerekisteri√§ ei ole viel√§ luotu")
        return
    
    with open(parties_file, 'r', encoding='utf-8') as f:
        data = json.load(f)
    
    # Etsi puolue
    party_index = next((i for i, p in enumerate(data["parties"]) if p["party_id"] == party_id), None)
    if party_index is None:
        click.echo(f"‚ùå Puoluetta '{party_id}' ei l√∂ydy")
        return
    
    party = data["parties"][party_index]
    
    # Poista puolue
    removed_party = data["parties"].pop(party_index)
    data["metadata"]["last_updated"] = datetime.now().isoformat()
    
    # Lis√§√§ historiaan
    data["verification_history"].append({
        "party_id": party_id,
        "timestamp": datetime.now().isoformat(),
        "action": "removed",
        "by_node": "system",
        "reason": "Puolue poistettu manuaalisesti"
    })
    
    # Tallenna
    with open(parties_file, 'w', encoding='utf-8') as f:
        json.dump(data, f, indent=2, ensure_ascii=False)
    
    click.echo(f"‚úÖ Puolue poistettu: {removed_party['name']['fi']} ({party_id})")
    click.echo(f"üìù Puolueessa oli {len(removed_party['candidates'])} ehdokasta")

if __name__ == '__main__':
    manage_parties()
```

## src/cli/manage_answers_refactored.py
```python
#!/usr/bin/env python3
import click
from datetime import datetime
from src.cli.base_cli import BaseCLI

@click.group()
def manage_answers():
    """Ehdokkaiden vastausten hallinta (refaktoroitu)"""
    pass

class AnswerManagerCLI(BaseCLI):
    def add_answer(self, candidate_id, question_id, answer_value, confidence, explanations):
        """Lis√§√§ vastaus (refaktoroitu)"""
        # K√§yt√§ data_manager ja validator -ei toistuvaa koodia
        if not self.validator.validate_candidate_exists(candidate_id, self.data_manager):
            raise ValueError(f"Ehdokas {candidate_id} ei ole olemassa")
        
        # ... lyhennetty refaktoroitu logiikka
        pass

@manage_answers.command()
@click.option('--election', required=True, help='Vaalin tunniste')
@click.option('--candidate-id', required=True, help='Ehdokkaan tunniste')
def list_answers(election, candidate_id):
    """Listaa vastaukset (refaktoroitu)"""
    cli = AnswerManagerCLI(election)
    cli.validate_election()
    
    # K√§yt√§ yhteisi√§ metodeja
    answers = cli.list_answers(candidate_id)
    # ... n√§yt√§ tulokset
```

## src/cli/install.py
```python
#!/usr/bin/env python3
import click
import json
from datetime import datetime
import os

@click.command()
@click.option('--election-id', required=True, help='Vaalin tunniste')
@click.option('--first-install', is_flag=True, help='Ensimm√§inen asennus')
def install_system(election_id, first_install):
    """Asenna vaalij√§rjestelm√§"""
    click.echo(f"üèõÔ∏è Asennetaan Jumaltenvaalit: {election_id}")
    
    # Luo data-hakemisto
    os.makedirs("data/runtime", exist_ok=True)
    
    # Luo system_chain.json
    system_chain = {
        "chain_id": f"system_chain_{election_id}",
        "created_at": datetime.now().isoformat(),
        "description": f"Jumaltenvaalit 2026 - {election_id}",
        "version": "2.0.0",
        "blocks": [
            {
                "block_id": 0,
                "timestamp": datetime.now().isoformat(),
                "action_type": "divine_installation",
                "description": f"Jumaltenvaalit asennettu: {election_id}",
                "user_id": "zeus",
                "previous_hash": None,
                "block_hash": "initial_olympus_hash"
            }
        ]
    }
    
    with open("data/runtime/system_chain.json", "w") as f:
        json.dump(system_chain, f, indent=2)
    
    # Luo meta.json
    meta_data = {
        "metadata": {
            "version": "2.0.0", 
            "created": datetime.now().isoformat(),
            "election_id": election_id,
            "node_id": "olympus_master",
            "system_locked": False,
            "mode": "development",
            "divine_council": True
        }
    }
    
    with open("data/runtime/meta.json", "w") as f:
        json.dump(meta_data, f, indent=2)
    
    click.echo("‚úÖ Jumaltenvaalit asennettu onnistuneesti!")
    click.echo("‚ö° Olympos on valmis vaaleille!")

if __name__ == '__main__':
    install_system()
```

## src/cli/analytics.py
```python
#!/usr/bin/env python3
"""
Analytics ja tilastoty√∂kalu
"""
import click
import json
import sys
import os

sys.path.append(os.path.join(os.path.dirname(__file__), '..'))
from managers.analytics_manager import AnalyticsManager
from core.error_handling import handle_file_errors, validate_election_exists

@click.group()
def analytics():
    """Analytics ja tilastoty√∂kalut"""
    pass

@analytics.command()
@click.option('--election', required=True, help='Vaalin tunniste')
@handle_file_errors
def stats(election):
    """N√§yt√§ j√§rjestelm√§n tilastot"""
    validate_election_exists(election)
    
    manager = AnalyticsManager(election)
    stats = manager.get_system_stats()
    
    click.echo("üìä J√ÑRJESTELM√ÑTILASTOT")
    click.echo("=" * 60)
    
    click.echo(f"üèõÔ∏è  Vaali: {stats['election_id']}")
    click.echo(f"üïí Luotu: {stats['generated_at'][:16]}")
    click.echo()
    
    # Sis√§lt√∂tilastot
    content = stats['content_stats']
    click.echo("üìà SIS√ÑLL√ñN TILASTOT:")
    click.echo(f"   ‚ùì Kysymyksi√§: {content.get('questions', 0)}")
    if 'avg_elo_rating' in content:
        click.echo(f"   ‚≠ê Keskim. ELO: {content['avg_elo_rating']} ({content['min_elo_rating']}-{content['max_elo_rating']})")
    
    click.echo(f"   üëë Ehdokkaita: {content.get('candidates', 0)}")
    click.echo(f"   üìù Vastauksia: {content.get('total_answers', 0)}")
    if 'answer_coverage_percent' in content:
        click.echo(f"   üéØ Vastauskattavuus: {content['answer_coverage_percent']}%")
    
    click.echo(f"   üèõÔ∏è  Puolueita: {content.get('parties', 0)}")
    click.echo(f"   ‚úÖ Vahvistettuja: {content.get('verified_parties', 0)}")
    click.echo(f"   ‚è≥ Odottavia: {content.get('pending_parties', 0)}")

@analytics.command()
@click.option('--election', required=True, help='Vaalin tunniste')
@handle_file_errors
def health(election):
    """N√§yt√§ j√§rjestelm√§n terveysraportti"""
    validate_election_exists(election)
    
    manager = AnalyticsManager(election)
    report = manager.generate_health_report()
    
    click.echo("üè• J√ÑRJESTELM√ÑN TERVEYSRAPORTTI")
    click.echo("=" * 60)
    
    health_icon = "‚úÖ" if report["system_health"] == "healthy" else "‚ö†Ô∏è"
    click.echo(f"{health_icon} Tila: {report['system_health']}")
    click.echo()
    
    if report["issues"]:
        click.echo("üö® L√ñYDETYT ONGELMAT:")
        for issue in report["issues"]:
            click.echo(f"   ‚Ä¢ {issue}")
        click.echo()
    
    if report["recommendations"]:
        click.echo("üí° SUOSITUKSET:")
        for recommendation in report["recommendations"]:
            click.echo(f"   ‚Ä¢ {recommendation}")
        click.echo()
    
    # N√§yt√§ kysymysten analytics
    if report.get("question_analytics"):
        qa = report["question_analytics"]
        click.echo("üìä KYSYMYSTEN ANALYTICS:")
        click.echo(f"   Yhteens√§: {qa['total_questions']} kysymyst√§")
        
        click.echo("   üè∑Ô∏è  Kategoriat:")
        for category, count in qa["categories"].items():
            click.echo(f"      ‚Ä¢ {category}: {count} kysymyst√§")
        
        click.echo("   üèÜ TOP 5 KYSYMYST√Ñ:")
        for q in qa["elo_distribution"]["top_5"]:
            click.echo(f"      ‚≠ê {q['rating']} - {q['question']}")

@analytics.command()
@click.option('--election', required=True, help='Vaalin tunniste')
@click.option('--output', help='Tallenna raportti tiedostoon')
@handle_file_errors
def report(election, output):
    """Luo kattava analytics-raportti"""
    validate_election_exists(election)
    
    manager = AnalyticsManager(election)
    stats = manager.get_system_stats()
    question_analytics = manager.get_question_analytics()
    health_report = manager.generate_health_report()
    
    full_report = {
        "metadata": {
            "election_id": election,
            "generated_at": stats["generated_at"],
            "report_type": "full_analytics"
        },
        "system_stats": stats,
        "question_analytics": question_analytics,
        "health_report": health_report
    }
    
    if output:
        with open(output, 'w', encoding='utf-8') as f:
            json.dump(full_report, f, indent=2, ensure_ascii=False)
        click.echo(f"‚úÖ Raportti tallennettu: {output}")
    else:
        click.echo(json.dumps(full_report, indent=2, ensure_ascii=False))

if __name__ == '__main__':
    analytics()
```

